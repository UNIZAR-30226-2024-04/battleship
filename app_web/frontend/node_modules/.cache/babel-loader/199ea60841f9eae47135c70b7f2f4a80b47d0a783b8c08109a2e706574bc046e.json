{"ast":null,"code":"/*!\n * GridStack 10.1.1\n * https://gridstackjs.com/\n *\n * Copyright (c) 2021-2022 Alain Dumesny\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\n */\nimport { GridStackEngine } from './gridstack-engine';\nimport { Utils, obsolete } from './utils';\nimport { gridDefaults, dragInDefaultOptions } from './types';\n/*\n * and include D&D by default\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n */\nimport { DDGridStack } from './dd-gridstack';\nimport { isTouch } from './dd-touch';\nimport { DDManager } from './dd-manager';\nconst dd = new DDGridStack();\n// export all dependent file as well to make it easier for users to just import the main file\nexport * from './types';\nexport * from './utils';\nexport * from './gridstack-engine';\nexport * from './dd-gridstack';\n/**\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\n * @example\n * <div class=\"grid-stack\">\n *   <div class=\"grid-stack-item\">\n *     <div class=\"grid-stack-item-content\">Item 1</div>\n *   </div>\n * </div>\n */\nclass GridStack {\n  /**\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\n   * @param options grid options (optional)\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\n   *\n   * @example\n   * let grid = GridStack.init();\n   *\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\n   * let grid = document.querySelector('.grid-stack').gridstack;\n   */\n  static init(options = {}, elOrString = '.grid-stack') {\n    if (typeof document === 'undefined') return null; // temp workaround SSR\n    let el = GridStack.getGridElement(elOrString);\n    if (!el) {\n      if (typeof elOrString === 'string') {\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n      } else {\n        console.error('GridStack.init() no grid element was passed.');\n      }\n      return null;\n    }\n    if (!el.gridstack) {\n      el.gridstack = new GridStack(el, Utils.cloneDeep(options));\n    }\n    return el.gridstack;\n  }\n  /**\n   * Will initialize a list of elements (given a selector) and return an array of grids.\n   * @param options grid options (optional)\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\n   *\n   * @example\n   * let grids = GridStack.initAll();\n   * grids.forEach(...)\n   */\n  static initAll(options = {}, selector = '.grid-stack') {\n    let grids = [];\n    if (typeof document === 'undefined') return grids; // temp workaround SSR\n    GridStack.getGridElements(selector).forEach(el => {\n      if (!el.gridstack) {\n        el.gridstack = new GridStack(el, Utils.cloneDeep(options));\n      }\n      grids.push(el.gridstack);\n    });\n    if (grids.length === 0) {\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' + '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\n    }\n    return grids;\n  }\n  /**\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\n   * JSON serialized data, including options.\n   * @param parent HTML element parent to the grid\n   * @param opt grids options used to initialize the grid, and list of children\n   */\n  static addGrid(parent, opt = {}) {\n    if (!parent) return null;\n    let el = parent;\n    if (el.gridstack) {\n      // already a grid - set option and load data\n      const grid = el.gridstack;\n      if (opt) grid.opts = {\n        ...grid.opts,\n        ...opt\n      };\n      if (opt.children !== undefined) grid.load(opt.children);\n      return grid;\n    }\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\n    const parentIsGrid = parent.classList.contains('grid-stack');\n    if (!parentIsGrid || GridStack.addRemoveCB) {\n      if (GridStack.addRemoveCB) {\n        el = GridStack.addRemoveCB(parent, opt, true, true);\n      } else {\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || ''}\"></div>`;\n        el = doc.body.children[0];\n        parent.appendChild(el);\n      }\n    }\n    // create grid class and load any children\n    let grid = GridStack.init(opt, el);\n    return grid;\n  }\n  /** call this method to register your engine instead of the default one.\n   * See instead `GridStackOptions.engineClass` if you only need to\n   * replace just one instance.\n   */\n  static registerEngine(engineClass) {\n    GridStack.engineClass = engineClass;\n  }\n  /** @internal create placeholder DIV as needed */\n  get placeholder() {\n    if (!this._placeholder) {\n      let placeholderChild = document.createElement('div'); // child so padding match item-content\n      placeholderChild.className = 'placeholder-content';\n      if (this.opts.placeholderText) {\n        placeholderChild.innerHTML = this.opts.placeholderText;\n      }\n      this._placeholder = document.createElement('div');\n      this._placeholder.classList.add(this.opts.placeholderClass, gridDefaults.itemClass, this.opts.itemClass);\n      this.placeholder.appendChild(placeholderChild);\n    }\n    return this._placeholder;\n  }\n  /**\n   * Construct a grid item from the given element and options\n   * @param el the HTML element tied to this grid after it's been initialized\n   * @param opts grid options - public for classes to access, but use methods to modify!\n   */\n  constructor(el, opts = {}) {\n    this.el = el;\n    this.opts = opts;\n    /** @internal */\n    this._gsEventHandler = {};\n    /** @internal extra row added when dragging at the bottom of the grid */\n    this._extraDragRow = 0;\n    /** @internal meant to store the scale of the active grid */\n    this.dragTransform = {\n      xScale: 1,\n      yScale: 1,\n      xOffset: 0,\n      yOffset: 0\n    };\n    el.gridstack = this;\n    opts = opts || {}; // handles null/undefined/0\n    if (!el.classList.contains('grid-stack')) {\n      this.el.classList.add('grid-stack');\n    }\n    // if row property exists, replace minRow and maxRow instead\n    if (opts.row) {\n      opts.minRow = opts.maxRow = opts.row;\n      delete opts.row;\n    }\n    let rowAttr = Utils.toNumber(el.getAttribute('gs-row'));\n    // flag only valid in sub-grids (handled by parent, not here)\n    if (opts.column === 'auto') {\n      delete opts.column;\n    }\n    // save original setting so we can restore on save\n    if (opts.alwaysShowResizeHandle !== undefined) {\n      opts._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\n    }\n    let bk = opts.columnOpts?.breakpoints;\n    // LEGACY: oneColumnMode stuff changed in v10.x - check if user explicitly set something to convert over\n    const oldOpts = opts;\n    if (oldOpts.oneColumnModeDomSort) {\n      delete oldOpts.oneColumnModeDomSort;\n      console.log('warning: Gridstack oneColumnModeDomSort no longer supported. Use GridStackOptions.columnOpts instead.');\n    }\n    if (oldOpts.oneColumnSize || oldOpts.disableOneColumnMode === false) {\n      const oneSize = oldOpts.oneColumnSize || 768;\n      delete oldOpts.oneColumnSize;\n      delete oldOpts.disableOneColumnMode;\n      opts.columnOpts = opts.columnOpts || {};\n      bk = opts.columnOpts.breakpoints = opts.columnOpts.breakpoints || [];\n      let oneColumn = bk.find(b => b.c === 1);\n      if (!oneColumn) {\n        oneColumn = {\n          c: 1,\n          w: oneSize\n        };\n        bk.push(oneColumn, {\n          c: 12,\n          w: oneSize + 1\n        });\n      } else oneColumn.w = oneSize;\n    }\n    //...end LEGACY\n    // cleanup responsive opts (must have columnWidth | breakpoints) then sort breakpoints by size (so we can match during resize)\n    const resp = opts.columnOpts;\n    if (resp) {\n      if (!resp.columnWidth && !resp.breakpoints?.length) {\n        delete opts.columnOpts;\n        bk = undefined;\n      } else {\n        resp.columnMax = resp.columnMax || 12;\n      }\n    }\n    if (bk?.length > 1) bk.sort((a, b) => (b.w || 0) - (a.w || 0));\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\n    let defaults = {\n      ...Utils.cloneDeep(gridDefaults),\n      column: Utils.toNumber(el.getAttribute('gs-column')) || gridDefaults.column,\n      minRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-min-row')) || gridDefaults.minRow,\n      maxRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-max-row')) || gridDefaults.maxRow,\n      staticGrid: Utils.toBool(el.getAttribute('gs-static')) || gridDefaults.staticGrid,\n      draggable: {\n        handle: (opts.handleClass ? '.' + opts.handleClass : opts.handle ? opts.handle : '') || gridDefaults.draggable.handle\n      },\n      removableOptions: {\n        accept: opts.itemClass || gridDefaults.removableOptions.accept,\n        decline: gridDefaults.removableOptions.decline\n      }\n    };\n    if (el.getAttribute('gs-animate')) {\n      // default to true, but if set to false use that instead\n      defaults.animate = Utils.toBool(el.getAttribute('gs-animate'));\n    }\n    opts = Utils.defaults(opts, defaults);\n    this._initMargin(); // part of settings defaults...\n    // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\n    this.checkDynamicColumn();\n    this.el.classList.add('gs-' + opts.column);\n    if (opts.rtl === 'auto') {\n      opts.rtl = el.style.direction === 'rtl';\n    }\n    if (opts.rtl) {\n      this.el.classList.add('grid-stack-rtl');\n    }\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\n    const grandParent = this.el.parentElement?.parentElement;\n    let parentGridItem = grandParent?.classList.contains(gridDefaults.itemClass) ? grandParent.gridstackNode : undefined;\n    if (parentGridItem) {\n      parentGridItem.subGrid = this;\n      this.parentGridItem = parentGridItem;\n      this.el.classList.add('grid-stack-nested');\n      parentGridItem.el.classList.add('grid-stack-sub-grid');\n    }\n    this._isAutoCellHeight = opts.cellHeight === 'auto';\n    if (this._isAutoCellHeight || opts.cellHeight === 'initial') {\n      // make the cell content square initially (will use resize/column event to keep it square)\n      this.cellHeight(undefined, false);\n    } else {\n      // append unit if any are set\n      if (typeof opts.cellHeight == 'number' && opts.cellHeightUnit && opts.cellHeightUnit !== gridDefaults.cellHeightUnit) {\n        opts.cellHeight = opts.cellHeight + opts.cellHeightUnit;\n        delete opts.cellHeightUnit;\n      }\n      this.cellHeight(opts.cellHeight, false);\n    }\n    // see if we need to adjust auto-hide\n    if (opts.alwaysShowResizeHandle === 'mobile') {\n      opts.alwaysShowResizeHandle = isTouch;\n    }\n    this._styleSheetClass = 'gs-id-' + GridStackEngine._idSeq++;\n    this.el.classList.add(this._styleSheetClass);\n    this._setStaticClass();\n    let engineClass = opts.engineClass || GridStack.engineClass || GridStackEngine;\n    this.engine = new engineClass({\n      column: this.getColumn(),\n      float: opts.float,\n      maxRow: opts.maxRow,\n      onChange: cbNodes => {\n        let maxH = 0;\n        this.engine.nodes.forEach(n => {\n          maxH = Math.max(maxH, n.y + n.h);\n        });\n        cbNodes.forEach(n => {\n          let el = n.el;\n          if (!el) return;\n          if (n._removeDOM) {\n            if (el) el.remove();\n            delete n._removeDOM;\n          } else {\n            this._writePosAttr(el, n);\n          }\n        });\n        this._updateStyles(false, maxH); // false = don't recreate, just append if need be\n      }\n    });\n    // create initial global styles BEFORE loading children so resizeToContent margin can be calculated correctly\n    this._updateStyles(false, 0);\n    if (opts.auto) {\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\n      this.getGridItems().forEach(el => this._prepareElement(el));\n      this.batchUpdate(false);\n    }\n    // load any passed in children as well, which overrides any DOM layout done above\n    if (opts.children) {\n      let children = opts.children;\n      delete opts.children;\n      if (children.length) this.load(children); // don't load empty\n    }\n    // if (this.engine.nodes.length) this._updateStyles(); // update based on # of children. done in engine onChange CB\n    this.setAnimation(opts.animate);\n    // dynamic grids require pausing during drag to detect over to nest vs push\n    if (opts.subGridDynamic && !DDManager.pauseDrag) DDManager.pauseDrag = true;\n    if (opts.draggable?.pause !== undefined) DDManager.pauseDrag = opts.draggable.pause;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this._updateResizeEvent();\n  }\n  /**\n   * add a new widget and returns it.\n   *\n   * Widget will be always placed even if result height is more than actual grid height.\n   * You need to use `willItFit()` before calling addWidget for additional check.\n   * See also `makeWidget()`.\n   *\n   * @example\n   * let grid = GridStack.init();\n   * grid.addWidget({w: 3, content: 'hello'});\n   * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\n   *\n   * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\n   * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\n   */\n  addWidget(els, options) {\n    function isGridStackWidget(w) {\n      return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\n    }\n    let el;\n    let node;\n    if (typeof els === 'string') {\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n      doc.body.innerHTML = els;\n      el = doc.body.children[0];\n    } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\n      node = options = els;\n      if (node?.el) {\n        el = node.el; // re-use element stored in the node\n      } else if (GridStack.addRemoveCB) {\n        el = GridStack.addRemoveCB(this.el, options, true, false);\n      } else {\n        let content = options?.content || '';\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || ''}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\n        el = doc.body.children[0];\n      }\n    } else {\n      el = els;\n    }\n    if (!el) return;\n    // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\n    node = el.gridstackNode;\n    if (node && el.parentElement === this.el && this.engine.nodes.find(n => n._id === node._id)) return el;\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\n    let domAttr = this._readAttr(el);\n    options = Utils.cloneDeep(options) || {}; // make a copy before we modify in case caller re-uses it\n    Utils.defaults(options, domAttr);\n    node = this.engine.prepareNode(options);\n    this._writeAttr(el, options);\n    if (this._insertNotAppend) {\n      this.el.prepend(el);\n    } else {\n      this.el.appendChild(el);\n    }\n    this.makeWidget(el, options);\n    return el;\n  }\n  /**\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\n   * from the parent's subGrid options.\n   * @param el gridItem element to convert\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\n   * @param saveContent if true (default) the html inside .grid-stack-content will be saved to child widget\n   * @returns newly created grid\n   */\n  makeSubGrid(el, ops, nodeToAdd, saveContent = true) {\n    let node = el.gridstackNode;\n    if (!node) {\n      node = this.makeWidget(el).gridstackNode;\n    }\n    if (node.subGrid?.el) return node.subGrid; // already done\n    // find the template subGrid stored on a parent as fallback...\n    let subGridTemplate; // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let grid = this;\n    while (grid && !subGridTemplate) {\n      subGridTemplate = grid.opts?.subGridOpts;\n      grid = grid.parentGridItem?.grid;\n    }\n    //... and set the create options\n    ops = Utils.cloneDeep({\n      ...(subGridTemplate || {}),\n      children: undefined,\n      ...(ops || node.subGridOpts || {})\n    });\n    node.subGridOpts = ops;\n    // if column special case it set, remember that flag and set default\n    let autoColumn;\n    if (ops.column === 'auto') {\n      autoColumn = true;\n      ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\n      delete ops.columnOpts; // driven by parent\n    }\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\n    let content = node.el.querySelector('.grid-stack-item-content');\n    let newItem;\n    let newItemOpt;\n    if (saveContent) {\n      this._removeDD(node.el); // remove D&D since it's set on content div\n      newItemOpt = {\n        ...node,\n        x: 0,\n        y: 0\n      };\n      Utils.removeInternalForSave(newItemOpt);\n      delete newItemOpt.subGridOpts;\n      if (node.content) {\n        newItemOpt.content = node.content;\n        delete node.content;\n      }\n      if (GridStack.addRemoveCB) {\n        newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\n      } else {\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\n        doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\n        newItem = doc.body.children[0];\n        newItem.appendChild(content);\n        doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\n        content = doc.body.children[0];\n        node.el.appendChild(content);\n      }\n      this._prepareDragDropByNode(node); // ... and restore original D&D\n    }\n    // if we're adding an additional item, make the container large enough to have them both\n    if (nodeToAdd) {\n      let w = autoColumn ? ops.column : node.w;\n      let h = node.h + nodeToAdd.h;\n      let style = node.el.style;\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\n      this.update(node.el, {\n        w,\n        h\n      });\n      setTimeout(() => style.transition = null); // recover animation\n    }\n    let subGrid = node.subGrid = GridStack.addGrid(content, ops);\n    if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\n    if (autoColumn) subGrid._autoColumn = true;\n    // add the original content back as a child of hte newly created grid\n    if (saveContent) {\n      subGrid.addWidget(newItem, newItemOpt);\n    }\n    // now add any additional node\n    if (nodeToAdd) {\n      if (nodeToAdd._moving) {\n        // create an artificial event even for the just created grid to receive this item\n        window.setTimeout(() => Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\n      } else {\n        subGrid.addWidget(node.el, node);\n      }\n    }\n    return subGrid;\n  }\n  /**\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\n   */\n  removeAsSubGrid(nodeThatRemoved) {\n    let pGrid = this.parentGridItem?.grid;\n    if (!pGrid) return;\n    pGrid.batchUpdate();\n    pGrid.removeWidget(this.parentGridItem.el, true, true);\n    this.engine.nodes.forEach(n => {\n      // migrate any children over and offsetting by our location\n      n.x += this.parentGridItem.x;\n      n.y += this.parentGridItem.y;\n      pGrid.addWidget(n.el, n);\n    });\n    pGrid.batchUpdate(false);\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\n    delete this.parentGridItem;\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\n    if (nodeThatRemoved) {\n      window.setTimeout(() => Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\n    }\n  }\n  /**\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\n   * be removed.\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\n   * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\n   * @returns list of widgets or full grid option, including .children list of widgets\n   */\n  save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB) {\n    // return copied GridStackWidget (with optionally .el) we can modify at will...\n    let list = this.engine.save(saveContent, saveCB);\n    // check for HTML content and nested grids\n    list.forEach(n => {\n      if (saveContent && n.el && !n.subGrid && !saveCB) {\n        // sub-grid are saved differently, not plain content\n        let sub = n.el.querySelector('.grid-stack-item-content');\n        n.content = sub ? sub.innerHTML : undefined;\n        if (!n.content) delete n.content;\n      } else {\n        if (!saveContent && !saveCB) {\n          delete n.content;\n        }\n        // check for nested grid\n        if (n.subGrid?.el) {\n          const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\n          n.subGridOpts = saveGridOpt ? listOrOpt : {\n            children: listOrOpt\n          };\n          delete n.subGrid;\n        }\n      }\n      delete n.el;\n    });\n    // check if save entire grid options (needed for recursive) + children...\n    if (saveGridOpt) {\n      let o = Utils.cloneDeep(this.opts);\n      // delete default values that will be recreated on launch\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\n        o.margin = o.marginTop;\n        delete o.marginTop;\n        delete o.marginRight;\n        delete o.marginBottom;\n        delete o.marginLeft;\n      }\n      if (o.rtl === (this.el.style.direction === 'rtl')) {\n        o.rtl = 'auto';\n      }\n      if (this._isAutoCellHeight) {\n        o.cellHeight = 'auto';\n      }\n      if (this._autoColumn) {\n        o.column = 'auto';\n      }\n      const origShow = o._alwaysShowResizeHandle;\n      delete o._alwaysShowResizeHandle;\n      if (origShow !== undefined) {\n        o.alwaysShowResizeHandle = origShow;\n      } else {\n        delete o.alwaysShowResizeHandle;\n      }\n      Utils.removeInternalAndSame(o, gridDefaults);\n      o.children = list;\n      return o;\n    }\n    return list;\n  }\n  /**\n   * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\n   *\n   * @param layout list of widgets definition to update/create\n   * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\n   * the user control of insertion.\n   *\n   * @example\n   * see http://gridstackjs.com/demo/serialization.html\n   */\n  load(items, addRemove = GridStack.addRemoveCB || true) {\n    items = Utils.cloneDeep(items); // so we can mod\n    const column = this.getColumn();\n    // if passed list has coordinates, use them (insert from end to beginning for conflict resolution) else keep widget order\n    const haveCoord = items.some(w => w.x !== undefined || w.y !== undefined);\n    if (haveCoord) items = Utils.sort(items, -1, column);\n    this._insertNotAppend = haveCoord; // if we create in reverse order...\n    // if we're loading a layout into for example 1 column and items don't fit, make sure to save\n    // the original wanted layout so we can scale back up correctly #1471\n    if (items.some(n => (n.x || 0) + (n.w || 1) > column)) {\n      this._ignoreLayoutsNodeChange = true; // skip layout update\n      this.engine.cacheLayout(items, 12, true); // TODO: 12 is arbitrary. use max value in layout ?\n    }\n    // if given a different callback, temporally set it as global option so creating will use it\n    const prevCB = GridStack.addRemoveCB;\n    if (typeof addRemove === 'function') GridStack.addRemoveCB = addRemove;\n    let removed = [];\n    this.batchUpdate();\n    // if we are blank (loading into empty like startup) temp remove animation\n    const noAnim = !this.engine.nodes.length;\n    if (noAnim) this.setAnimation(false);\n    // see if any items are missing from new layout and need to be removed first\n    if (addRemove) {\n      let copyNodes = [...this.engine.nodes]; // don't loop through array you modify\n      copyNodes.forEach(n => {\n        if (!n.id) return;\n        let item = Utils.find(items, n.id);\n        if (!item) {\n          if (GridStack.addRemoveCB) GridStack.addRemoveCB(this.el, n, false, false);\n          removed.push(n); // batch keep track\n          this.removeWidget(n.el, true, false);\n        }\n      });\n    }\n    // now add/update the widgets - starting with removing items in the new layout we will reposition\n    // to reduce collision and add no-coord ones at next available spot\n    let updateNodes = [];\n    this.engine.nodes = this.engine.nodes.filter(n => {\n      if (Utils.find(items, n.id)) {\n        updateNodes.push(n);\n        return false;\n      } // remove if found from list\n      return true;\n    });\n    items.forEach(w => {\n      let item = Utils.find(updateNodes, w.id);\n      if (item) {\n        // if item sizes to content, re-use the exiting height so it's a better guess at the final size (same if width doesn't change)\n        if (Utils.shouldSizeToContent(item)) w.h = item.h;\n        // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\n        this.engine.nodeBoundFix(w);\n        if (w.autoPosition || w.x === undefined || w.y === undefined) {\n          w.w = w.w || item.w;\n          w.h = w.h || item.h;\n          this.engine.findEmptyPosition(w);\n        }\n        // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now\n        this.engine.nodes.push(item);\n        if (Utils.samePos(item, w)) {\n          this.moveNode(item, {\n            ...w,\n            forceCollide: true\n          });\n        }\n        this.update(item.el, w);\n        if (w.subGridOpts?.children) {\n          // update any sub grid as well\n          let sub = item.el.querySelector('.grid-stack');\n          if (sub && sub.gridstack) {\n            sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\n            this._insertNotAppend = true; // got reset by above call\n          }\n        }\n      } else if (addRemove) {\n        this.addWidget(w);\n      }\n    });\n    this.engine.removedNodes = removed;\n    this.batchUpdate(false);\n    // after commit, clear that flag\n    delete this._ignoreLayoutsNodeChange;\n    delete this._insertNotAppend;\n    prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\n    // delay adding animation back\n    if (noAnim && this.opts.animate) setTimeout(() => this.setAnimation(this.opts.animate));\n    return this;\n  }\n  /**\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\n   */\n  batchUpdate(flag = true) {\n    this.engine.batchUpdate(flag);\n    if (!flag) {\n      this._updateContainerHeight();\n      this._triggerRemoveEvent();\n      this._triggerAddEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * Gets current cell height.\n   */\n  getCellHeight(forcePixel = false) {\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' && (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\n      return this.opts.cellHeight;\n    }\n    // do rem/em/cm/mm to px conversion\n    if (this.opts.cellHeightUnit === 'rem') {\n      return this.opts.cellHeight * parseFloat(getComputedStyle(document.documentElement).fontSize);\n    }\n    if (this.opts.cellHeightUnit === 'em') {\n      return this.opts.cellHeight * parseFloat(getComputedStyle(this.el).fontSize);\n    }\n    if (this.opts.cellHeightUnit === 'cm') {\n      // 1cm = 96px/2.54. See https://www.w3.org/TR/css-values-3/#absolute-lengths\n      return this.opts.cellHeight * (96 / 2.54);\n    }\n    if (this.opts.cellHeightUnit === 'mm') {\n      return this.opts.cellHeight * (96 / 2.54) / 10;\n    }\n    // else get first cell height\n    let el = this.el.querySelector('.' + this.opts.itemClass);\n    if (el) {\n      let h = Utils.toNumber(el.getAttribute('gs-h')) || 1; // since we don't write 1 anymore\n      return Math.round(el.offsetHeight / h);\n    }\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\n    let rows = parseInt(this.el.getAttribute('gs-current-row'));\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight;\n  }\n  /**\n   * Update current cell height - see `GridStackOptions.cellHeight` for format.\n   * This method rebuilds an internal CSS style sheet.\n   * Note: You can expect performance issues if call this method too often.\n   *\n   * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\n   * if pass 0 the CSS will be generated by the application instead.\n   * @param update (Optional) if false, styles will not be updated\n   *\n   * @example\n   * grid.cellHeight(100); // same as 100px\n   * grid.cellHeight('70px');\n   * grid.cellHeight(grid.cellWidth() * 1.2);\n   */\n  cellHeight(val, update = true) {\n    // if not called internally, check if we're changing mode\n    if (update && val !== undefined) {\n      if (this._isAutoCellHeight !== (val === 'auto')) {\n        this._isAutoCellHeight = val === 'auto';\n        this._updateResizeEvent();\n      }\n    }\n    if (val === 'initial' || val === 'auto') {\n      val = undefined;\n    }\n    // make item content be square\n    if (val === undefined) {\n      let marginDiff = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom;\n      val = this.cellWidth() + marginDiff;\n    }\n    let data = Utils.parseHeight(val);\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\n      return this;\n    }\n    this.opts.cellHeightUnit = data.unit;\n    this.opts.cellHeight = data.h;\n    this.resizeToContentCheck();\n    if (update) {\n      this._updateStyles(true); // true = force re-create for current # of rows\n    }\n    return this;\n  }\n  /** Gets current cell width. */\n  cellWidth() {\n    return this._widthOrContainer() / this.getColumn();\n  }\n  /** return our expected width (or parent) , and optionally of window for dynamic column check */\n  _widthOrContainer(forBreakpoint = false) {\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\n    return forBreakpoint && this.opts.columnOpts?.breakpointForWindow ? window.innerWidth : this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth;\n  }\n  /** checks for dynamic column count for our current size, returning true if changed */\n  checkDynamicColumn() {\n    const resp = this.opts.columnOpts;\n    if (!resp || !resp.columnWidth && !resp.breakpoints?.length) return false;\n    const column = this.getColumn();\n    let newColumn = column;\n    const w = this._widthOrContainer(true);\n    if (resp.columnWidth) {\n      newColumn = Math.min(Math.round(w / resp.columnWidth) || 1, resp.columnMax);\n    } else {\n      // find the closest breakpoint (already sorted big to small) that matches\n      newColumn = resp.columnMax;\n      let i = 0;\n      while (i < resp.breakpoints.length && w <= resp.breakpoints[i].w) {\n        newColumn = resp.breakpoints[i++].c || column;\n      }\n    }\n    if (newColumn !== column) {\n      const bk = resp.breakpoints?.find(b => b.c === newColumn);\n      this.column(newColumn, bk?.layout || resp.layout);\n      return true;\n    }\n    return false;\n  }\n  /**\n   * re-layout grid items to reclaim any empty space. Options are:\n   * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\n   * 'compact' might re-order items to fill any empty space\n   *\n   * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)\n   */\n  compact(layout = 'compact', doSort = true) {\n    this.engine.compact(layout, doSort);\n    this._triggerChangeEvent();\n    return this;\n  }\n  /**\n   * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\n   * as well as cache the original layout so you can revert back to previous positions without loss.\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\n   * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\n   * @param column - Integer > 0 (default 12).\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\n   * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column\n   */\n  column(column, layout = 'moveScale') {\n    if (!column || column < 1 || this.opts.column === column) return this;\n    let oldColumn = this.getColumn();\n    this.opts.column = column;\n    if (!this.engine) return this; // called in constructor, noting else to do\n    this.engine.column = column;\n    this.el.classList.remove('gs-' + oldColumn);\n    this.el.classList.add('gs-' + column);\n    // update the items now, checking if we have a custom children layout\n    /*const newChildren = this.opts.columnOpts?.breakpoints?.find(r => r.c === column)?.children;\n    if (newChildren) this.load(newChildren);\n    else*/\n    this.engine.columnChanged(oldColumn, column, layout);\n    if (this._isAutoCellHeight) this.cellHeight();\n    this.resizeToContentCheck(true); // wait for width resizing\n    // and trigger our event last...\n    this._ignoreLayoutsNodeChange = true; // skip layout update\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return this;\n  }\n  /**\n   * get the number of columns in the grid (default 12)\n   */\n  getColumn() {\n    return this.opts.column;\n  }\n  /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */\n  getGridItems() {\n    return Array.from(this.el.children).filter(el => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass));\n  }\n  /**\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\n   */\n  destroy(removeDOM = true) {\n    if (!this.el) return; // prevent multiple calls\n    this.offAll();\n    this._updateResizeEvent(true);\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\n    this.setAnimation(false);\n    if (!removeDOM) {\n      this.removeAll(removeDOM);\n      this.el.classList.remove(this._styleSheetClass);\n      this.el.removeAttribute('gs-current-row');\n    } else {\n      this.el.parentNode.removeChild(this.el);\n    }\n    this._removeStylesheet();\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\n    delete this.parentGridItem;\n    delete this.opts;\n    delete this._placeholder;\n    delete this.engine;\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\n    delete this.el;\n    return this;\n  }\n  /**\n   * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\n   */\n  float(val) {\n    if (this.opts.float !== val) {\n      this.opts.float = this.engine.float = val;\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * get the current float mode\n   */\n  getFloat() {\n    return this.engine.float;\n  }\n  /**\n   * Get the position of the cell under a pixel on screen.\n   * @param position the position of the pixel to resolve in\n   * absolute coordinates, as an object with top and left properties\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\n   * Useful when grid is within `position: relative` element\n   *\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\n   */\n  getCellFromPixel(position, useDocRelative = false) {\n    let box = this.el.getBoundingClientRect();\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\n    let containerPos;\n    if (useDocRelative) {\n      containerPos = {\n        top: box.top + document.documentElement.scrollTop,\n        left: box.left\n      };\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\n    } else {\n      containerPos = {\n        top: this.el.offsetTop,\n        left: this.el.offsetLeft\n      };\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\n    }\n    let relativeLeft = position.left - containerPos.left;\n    let relativeTop = position.top - containerPos.top;\n    let columnWidth = box.width / this.getColumn();\n    let rowHeight = box.height / parseInt(this.el.getAttribute('gs-current-row'));\n    return {\n      x: Math.floor(relativeLeft / columnWidth),\n      y: Math.floor(relativeTop / rowHeight)\n    };\n  }\n  /** returns the current number of rows, which will be at least `minRow` if set */\n  getRow() {\n    return Math.max(this.engine.getRow(), this.opts.minRow);\n  }\n  /**\n   * Checks if specified area is empty.\n   * @param x the position x.\n   * @param y the position y.\n   * @param w the width of to check\n   * @param h the height of to check\n   */\n  isAreaEmpty(x, y, w, h) {\n    return this.engine.isAreaEmpty(x, y, w, h);\n  }\n  /**\n   * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\n   * Makes the given element a widget and returns it.\n   * @param els widget or single selector to convert.\n   * @param options widget definition to use instead of reading attributes or using default sizing values\n   *\n   * @example\n   * let grid = GridStack.init();\n   * grid.el.appendChild('<div id=\"1\" gs-w=\"3\"></div>');\n   * grid.el.appendChild('<div id=\"2\"></div>');\n   * grid.makeWidget('1');\n   * grid.makeWidget('2', {w:2, content: 'hello'});\n   */\n  makeWidget(els, options) {\n    let el = GridStack.getElement(els);\n    this._prepareElement(el, true, options);\n    const node = el.gridstackNode;\n    this._updateContainerHeight();\n    // see if there is a sub-grid to create\n    if (node.subGridOpts) {\n      this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\n    }\n    // if we're adding an item into 1 column make sure\n    // we don't override the larger 12 column layout that was already saved. #1985\n    if (this.opts.column === 1) {\n      this._ignoreLayoutsNodeChange = true;\n    }\n    this._triggerAddEvent();\n    this._triggerChangeEvent();\n    delete this._ignoreLayoutsNodeChange;\n    return el;\n  }\n  on(name, callback) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.on(name, callback));\n      return this;\n    }\n    // native CustomEvent handlers - cash the generic handlers so we can easily remove\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      let noData = name === 'enable' || name === 'disable';\n      if (noData) {\n        this._gsEventHandler[name] = event => callback(event);\n      } else {\n        this._gsEventHandler[name] = event => callback(event, event.detail);\n      }\n      this.el.addEventListener(name, this._gsEventHandler[name]);\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize' || name === 'resizestop' || name === 'dropped' || name === 'resizecontent') {\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\n      // do same for start event to make it easier...\n      this._gsEventHandler[name] = callback;\n    } else {\n      console.error('GridStack.on(' + name + ') event not supported');\n    }\n    return this;\n  }\n  /**\n   * unsubscribe from the 'on' event GridStackEvent\n   * @param name of the event (see possible values) or list of names space separated\n   */\n  off(name) {\n    // check for array of names being passed instead\n    if (name.indexOf(' ') !== -1) {\n      let names = name.split(' ');\n      names.forEach(name => this.off(name));\n      return this;\n    }\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\n      // remove native CustomEvent handlers\n      if (this._gsEventHandler[name]) {\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\n      }\n    }\n    delete this._gsEventHandler[name];\n    return this;\n  }\n  /** remove all event handlers */\n  offAll() {\n    Object.keys(this._gsEventHandler).forEach(key => this.off(key));\n    return this;\n  }\n  /**\n   * Removes widget from the grid.\n   * @param el  widget or selector to modify\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\n   */\n  removeWidget(els, removeDOM = true, triggerEvent = true) {\n    GridStack.getElements(els).forEach(el => {\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\n      let node = el.gridstackNode;\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\n      if (!node) {\n        node = this.engine.nodes.find(n => el === n.el);\n      }\n      if (!node) return;\n      if (GridStack.addRemoveCB) {\n        GridStack.addRemoveCB(this.el, node, false, false);\n      }\n      // remove our DOM data (circular link) and drag&drop permanently\n      delete el.gridstackNode;\n      this._removeDD(el);\n      this.engine.removeNode(node, removeDOM, triggerEvent);\n      if (removeDOM && el.parentElement) {\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\n      }\n    });\n    if (triggerEvent) {\n      this._triggerRemoveEvent();\n      this._triggerChangeEvent();\n    }\n    return this;\n  }\n  /**\n   * Removes all widgets from the grid.\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\n   */\n  removeAll(removeDOM = true) {\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\n    this.engine.nodes.forEach(n => {\n      delete n.el.gridstackNode;\n      this._removeDD(n.el);\n    });\n    this.engine.removeAll(removeDOM);\n    this._triggerRemoveEvent();\n    return this;\n  }\n  /**\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\n   * @param doAnimate if true the grid will animate.\n   */\n  setAnimation(doAnimate) {\n    if (doAnimate) {\n      this.el.classList.add('grid-stack-animate');\n    } else {\n      this.el.classList.remove('grid-stack-animate');\n    }\n    return this;\n  }\n  /** @internal */\n  hasAnimationCSS() {\n    return this.el.classList.contains('grid-stack-animate');\n  }\n  /**\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\n   * Also toggle the grid-stack-static class.\n   * @param val if true the grid become static.\n   * @param updateClass true (default) if css class gets updated\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  setStatic(val, updateClass = true, recurse = true) {\n    if (!!this.opts.staticGrid === val) return this;\n    val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\n    this._setupRemoveDrop();\n    this._setupAcceptWidget();\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n); // either delete or init Drag&drop\n      if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\n    });\n    if (updateClass) {\n      this._setStaticClass();\n    }\n    return this;\n  }\n  /**\n   * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\n   * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\n   * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\n   */\n  update(els, opt) {\n    // support legacy call for now ?\n    if (arguments.length > 2) {\n      console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 1;\n      opt = {\n        x: a[i++],\n        y: a[i++],\n        w: a[i++],\n        h: a[i++]\n      };\n      return this.update(els, opt);\n    }\n    GridStack.getElements(els).forEach(el => {\n      let n = el?.gridstackNode;\n      if (!n) return;\n      let w = Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\n      this.engine.nodeBoundFix(w);\n      delete w.autoPosition;\n      delete w.id;\n      // move/resize widget if anything changed\n      let keys = ['x', 'y', 'w', 'h'];\n      let m;\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\n        m = {};\n        keys.forEach(k => {\n          m[k] = w[k] !== undefined ? w[k] : n[k];\n          delete w[k];\n        });\n      }\n      // for a move as well IFF there is any min/max fields set\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\n        m = {}; // will use node position but validate values\n      }\n      // check for content changing\n      if (w.content !== undefined) {\n        const itemContent = el.querySelector('.grid-stack-item-content');\n        if (itemContent && itemContent.innerHTML !== w.content) {\n          itemContent.innerHTML = w.content;\n          // restore any sub-grid back\n          if (n.subGrid?.el) {\n            itemContent.appendChild(n.subGrid.el);\n            if (!n.subGrid.opts.styleInHead) n.subGrid._updateStyles(true); // force create\n          }\n        }\n        delete w.content;\n      }\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\n      let changed = false;\n      let ddChanged = false;\n      for (const key in w) {\n        if (key[0] !== '_' && n[key] !== w[key]) {\n          n[key] = w[key];\n          changed = true;\n          ddChanged = ddChanged || !this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked');\n        }\n      }\n      Utils.sanitizeMinMax(n);\n      // finally move the widget and update attr\n      if (m) {\n        const widthChanged = m.w !== undefined && m.w !== n.w;\n        this.moveNode(n, m);\n        this.resizeToContentCheck(widthChanged, n); // wait for animation if we changed width\n      }\n      if (m || changed) {\n        this._writeAttr(el, n);\n      }\n      if (ddChanged) {\n        this._prepareDragDropByNode(n);\n      }\n    });\n    return this;\n  }\n  moveNode(n, m) {\n    this.engine.cleanNodes().beginUpdate(n).moveNode(n, m);\n    this._updateContainerHeight();\n    this._triggerChangeEvent();\n    this.engine.endUpdate();\n  }\n  /**\n   * Updates widget height to match the content height to avoid v-scrollbar or dead space.\n   * Note: this assumes only 1 child under resizeToContentParent='.grid-stack-item-content' (sized to gridItem minus padding) that is at the entire content size wanted.\n   * @param el grid item element\n   * @param useNodeH set to true if GridStackNode.h should be used instead of actual container height when we don't need to wait for animation to finish to get actual DOM heights\n   */\n  resizeToContent(el) {\n    if (!el) return;\n    el.classList.remove('size-to-content-max');\n    if (!el.clientHeight) return; // 0 when hidden, skip\n    const n = el.gridstackNode;\n    if (!n) return;\n    const grid = n.grid;\n    if (!grid || el.parentElement !== grid.el) return; // skip if we are not inside a grid\n    const cell = grid.getCellHeight(true);\n    if (!cell) return;\n    let height = n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth\n    let item;\n    if (n.resizeToContentParent) item = el.querySelector(n.resizeToContentParent);\n    if (!item) item = el.querySelector(GridStack.resizeToContentParent);\n    if (!item) return;\n    const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)\n    const itemH = n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)\n    let wantedH;\n    if (n.subGrid) {\n      // sub-grid - use their actual row count * their cell height\n      wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight(true);\n    } else {\n      // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!\n      const child = item.firstElementChild;\n      if (!child) {\n        console.error(`Error: GridStack.resizeToContent() widget id:${n.id} '${GridStack.resizeToContentParent}'.firstElementChild is null, make sure to have a div like container. Skipping sizing.`);\n        return;\n      }\n      wantedH = child.getBoundingClientRect().height || itemH;\n    }\n    if (itemH === wantedH) return;\n    height += wantedH - itemH;\n    let h = Math.ceil(height / cell);\n    // check for min/max and special sizing\n    const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent : 0;\n    if (softMax && h > softMax) {\n      h = softMax;\n      el.classList.add('size-to-content-max'); // get v-scroll back\n    }\n    if (n.minH && h < n.minH) h = n.minH;else if (n.maxH && h > n.maxH) h = n.maxH;\n    if (h !== n.h) {\n      grid._ignoreLayoutsNodeChange = true;\n      grid.moveNode(n, {\n        h\n      });\n      delete grid._ignoreLayoutsNodeChange;\n    }\n  }\n  /** call the user resize (so they can do extra work) else our build in version */\n  resizeToContentCBCheck(el) {\n    if (GridStack.resizeToContentCB) GridStack.resizeToContentCB(el);else this.resizeToContent(el);\n  }\n  /**\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\n   * @param value margin value\n   */\n  margin(value) {\n    let isMultiValue = typeof value === 'string' && value.split(' ').length > 1;\n    // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\n    if (!isMultiValue) {\n      let data = Utils.parseHeight(value);\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\n    }\n    // re-use existing margin handling\n    this.opts.margin = value;\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\n    this._initMargin();\n    this._updateStyles(true); // true = force re-create\n    return this;\n  }\n  /** returns current margin number value (undefined if 4 sides don't match) */\n  getMargin() {\n    return this.opts.margin;\n  }\n  /**\n   * Returns true if the height of the grid will be less than the vertical\n   * constraint. Always returns true if grid doesn't have height constraint.\n   * @param node contains x,y,w,h,auto-position options\n   *\n   * @example\n   * if (grid.willItFit(newWidget)) {\n   *   grid.addWidget(newWidget);\n   * } else {\n   *   alert('Not enough free space to place the widget');\n   * }\n   */\n  willItFit(node) {\n    // support legacy call for now\n    if (arguments.length > 1) {\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\n      // eslint-disable-next-line prefer-rest-params\n      let a = arguments,\n        i = 0,\n        w = {\n          x: a[i++],\n          y: a[i++],\n          w: a[i++],\n          h: a[i++],\n          autoPosition: a[i++]\n        };\n      return this.willItFit(w);\n    }\n    return this.engine.willItFit(node);\n  }\n  /** @internal */\n  _triggerChangeEvent() {\n    if (this.engine.batchMode) return this;\n    let elements = this.engine.getDirtyNodes(true); // verify they really changed\n    if (elements && elements.length) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(elements);\n      }\n      this._triggerEvent('change', elements);\n    }\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\n    return this;\n  }\n  /** @internal */\n  _triggerAddEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.addedNodes?.length) {\n      if (!this._ignoreLayoutsNodeChange) {\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\n      }\n      // prevent added nodes from also triggering 'change' event (which is called next)\n      this.engine.addedNodes.forEach(n => {\n        delete n._dirty;\n      });\n      this._triggerEvent('added', this.engine.addedNodes);\n      this.engine.addedNodes = [];\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerRemoveEvent() {\n    if (this.engine.batchMode) return this;\n    if (this.engine.removedNodes?.length) {\n      this._triggerEvent('removed', this.engine.removedNodes);\n      this.engine.removedNodes = [];\n    }\n    return this;\n  }\n  /** @internal */\n  _triggerEvent(type, data) {\n    let event = data ? new CustomEvent(type, {\n      bubbles: false,\n      detail: data\n    }) : new Event(type);\n    this.el.dispatchEvent(event);\n    return this;\n  }\n  /** @internal called to delete the current dynamic style sheet used for our layout */\n  _removeStylesheet() {\n    if (this._styles) {\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n      Utils.removeStylesheet(this._styleSheetClass, styleLocation);\n      delete this._styles;\n    }\n    return this;\n  }\n  /** @internal updated/create the CSS styles for row based layout and initial margin setting */\n  _updateStyles(forceUpdate = false, maxH) {\n    // call to delete existing one if we change cellHeight / margin\n    if (forceUpdate) {\n      this._removeStylesheet();\n    }\n    if (maxH === undefined) maxH = this.getRow();\n    this._updateContainerHeight();\n    // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\n    if (this.opts.cellHeight === 0) {\n      return this;\n    }\n    let cellHeight = this.opts.cellHeight;\n    let cellHeightUnit = this.opts.cellHeightUnit;\n    let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\n    // create one as needed\n    if (!this._styles) {\n      // insert style to parent (instead of 'head' by default) to support WebComponent\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode;\n      this._styles = Utils.createStylesheet(this._styleSheetClass, styleLocation, {\n        nonce: this.opts.nonce\n      });\n      if (!this._styles) return this;\n      this._styles._max = 0;\n      // these are done once only\n      Utils.addCSSRule(this._styles, prefix, `height: ${cellHeight}${cellHeightUnit}`);\n      // content margins\n      let top = this.opts.marginTop + this.opts.marginUnit;\n      let bottom = this.opts.marginBottom + this.opts.marginUnit;\n      let right = this.opts.marginRight + this.opts.marginUnit;\n      let left = this.opts.marginLeft + this.opts.marginUnit;\n      let content = `${prefix} > .grid-stack-item-content`;\n      let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\n      Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\n      // resize handles offset (to match margin)\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-n`, `top: ${top};`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-s`, `bottom: ${bottom}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\n    }\n    // now update the height specific fields\n    maxH = maxH || this._styles._max;\n    if (maxH > this._styles._max) {\n      let getHeight = rows => cellHeight * rows + cellHeightUnit;\n      for (let i = this._styles._max + 1; i <= maxH; i++) {\n        // start at 1\n        Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i}\"]`, `top: ${getHeight(i)}`);\n        Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i + 1}\"]`, `height: ${getHeight(i + 1)}`); // start at 2\n      }\n      this._styles._max = maxH;\n    }\n    return this;\n  }\n  /** @internal */\n  _updateContainerHeight() {\n    if (!this.engine || this.engine.batchMode) return this;\n    const parent = this.parentGridItem;\n    let row = this.getRow() + this._extraDragRow; // this checks for minRow already\n    const cellHeight = this.opts.cellHeight;\n    const unit = this.opts.cellHeightUnit;\n    if (!cellHeight) return this;\n    // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.\n    if (!parent) {\n      const cssMinHeight = Utils.parseHeight(getComputedStyle(this.el)['minHeight']);\n      if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {\n        const minRow = Math.floor(cssMinHeight.h / cellHeight);\n        if (row < minRow) {\n          row = minRow;\n        }\n      }\n    }\n    this.el.setAttribute('gs-current-row', String(row));\n    this.el.style.removeProperty('min-height');\n    this.el.style.removeProperty('height');\n    if (row) {\n      // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars\n      this.el.style[parent ? 'minHeight' : 'height'] = row * cellHeight + unit;\n    }\n    // if we're a nested grid inside an sizeToContent item, tell it to resize itself too\n    if (parent && !parent.grid.engine.batchMode && Utils.shouldSizeToContent(parent)) {\n      parent.grid.resizeToContentCBCheck(parent.el);\n    }\n    return this;\n  }\n  /** @internal */\n  _prepareElement(el, triggerAddEvent = false, node) {\n    node = node || this._readAttr(el);\n    el.gridstackNode = node;\n    node.el = el;\n    node.grid = this;\n    node = this.engine.addNode(node, triggerAddEvent);\n    // write the dom sizes and class\n    this._writeAttr(el, node);\n    el.classList.add(gridDefaults.itemClass, this.opts.itemClass);\n    const sizeToContent = Utils.shouldSizeToContent(node);\n    sizeToContent ? el.classList.add('size-to-content') : el.classList.remove('size-to-content');\n    if (sizeToContent) this.resizeToContentCheck(false, node);\n    this._prepareDragDropByNode(node);\n    return this;\n  }\n  /** @internal call to write position x,y,w,h attributes back to element */\n  _writePosAttr(el, n) {\n    if (n.x !== undefined && n.x !== null) {\n      el.setAttribute('gs-x', String(n.x));\n    }\n    if (n.y !== undefined && n.y !== null) {\n      el.setAttribute('gs-y', String(n.y));\n    }\n    n.w > 1 ? el.setAttribute('gs-w', String(n.w)) : el.removeAttribute('gs-w');\n    n.h > 1 ? el.setAttribute('gs-h', String(n.h)) : el.removeAttribute('gs-h');\n    return this;\n  }\n  /** @internal call to write any default attributes back to element */\n  _writeAttr(el, node) {\n    if (!node) return this;\n    this._writePosAttr(el, node);\n    let attrs /*: GridStackWidget but strings */ = {\n      autoPosition: 'gs-auto-position',\n      noResize: 'gs-no-resize',\n      noMove: 'gs-no-move',\n      locked: 'gs-locked',\n      id: 'gs-id'\n    };\n    for (const key in attrs) {\n      if (node[key]) {\n        // 0 is valid for x,y only but done above already and not in list anyway\n        el.setAttribute(attrs[key], String(node[key]));\n      } else {\n        el.removeAttribute(attrs[key]);\n      }\n    }\n    return this;\n  }\n  /** @internal call to read any default attributes from element */\n  _readAttr(el, clearDefaultAttr = true) {\n    let n = {};\n    n.x = Utils.toNumber(el.getAttribute('gs-x'));\n    n.y = Utils.toNumber(el.getAttribute('gs-y'));\n    n.w = Utils.toNumber(el.getAttribute('gs-w'));\n    n.h = Utils.toNumber(el.getAttribute('gs-h'));\n    n.autoPosition = Utils.toBool(el.getAttribute('gs-auto-position'));\n    n.noResize = Utils.toBool(el.getAttribute('gs-no-resize'));\n    n.noMove = Utils.toBool(el.getAttribute('gs-no-move'));\n    n.locked = Utils.toBool(el.getAttribute('gs-locked'));\n    n.id = el.getAttribute('gs-id');\n    // read but never written out\n    n.maxW = Utils.toNumber(el.getAttribute('gs-max-w'));\n    n.minW = Utils.toNumber(el.getAttribute('gs-min-w'));\n    n.maxH = Utils.toNumber(el.getAttribute('gs-max-h'));\n    n.minH = Utils.toNumber(el.getAttribute('gs-min-h'));\n    // v8.x optimization to reduce un-needed attr that don't render or are default CSS\n    if (clearDefaultAttr) {\n      if (n.w === 1) el.removeAttribute('gs-w');\n      if (n.h === 1) el.removeAttribute('gs-h');\n      if (n.maxW) el.removeAttribute('gs-max-w');\n      if (n.minW) el.removeAttribute('gs-min-w');\n      if (n.maxH) el.removeAttribute('gs-max-h');\n      if (n.minH) el.removeAttribute('gs-min-h');\n    }\n    // remove any key not found (null or false which is default)\n    for (const key in n) {\n      if (!n.hasOwnProperty(key)) return;\n      if (!n[key] && n[key] !== 0) {\n        // 0 can be valid value (x,y only really)\n        delete n[key];\n      }\n    }\n    return n;\n  }\n  /** @internal */\n  _setStaticClass() {\n    let classes = ['grid-stack-static'];\n    if (this.opts.staticGrid) {\n      this.el.classList.add(...classes);\n      this.el.setAttribute('gs-static', 'true');\n    } else {\n      this.el.classList.remove(...classes);\n      this.el.removeAttribute('gs-static');\n    }\n    return this;\n  }\n  /**\n   * called when we are being resized - check if the one Column Mode needs to be turned on/off\n   * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)\n   * or `sizeToContent` gridItem options.\n   */\n  onResize() {\n    if (!this.el?.clientWidth) return; // return if we're gone or no size yet (will get called again)\n    if (this.prevWidth === this.el.clientWidth) return; // no-op\n    this.prevWidth = this.el.clientWidth;\n    // console.log('onResize ', this.el.clientWidth);\n    this.batchUpdate();\n    // see if we're nested and take our column count from our parent....\n    let columnChanged = false;\n    if (this._autoColumn && this.parentGridItem) {\n      if (this.opts.column !== this.parentGridItem.w) {\n        this.column(this.parentGridItem.w, 'none');\n        columnChanged = true;\n      }\n    } else {\n      // else check for dynamic column\n      columnChanged = this.checkDynamicColumn();\n    }\n    // make the cells content square again\n    if (this._isAutoCellHeight) this.cellHeight();\n    // update any nested grids, or items size\n    this.engine.nodes.forEach(n => {\n      if (n.subGrid) n.subGrid.onResize();\n    });\n    if (!this._skipInitialResize) this.resizeToContentCheck(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)\n    delete this._skipInitialResize;\n    this.batchUpdate(false);\n    return this;\n  }\n  /** resizes content for given node (or all) if shouldSizeToContent() is true */\n  resizeToContentCheck(delay = false, n = undefined) {\n    if (!this.engine) return; // we've been deleted in between!\n    // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count\n    // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?\n    if (delay && this.hasAnimationCSS()) return setTimeout(() => this.resizeToContentCheck(false, n), 300 + 10);\n    if (n) {\n      if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\n    } else if (this.engine.nodes.some(n => Utils.shouldSizeToContent(n))) {\n      const nodes = [...this.engine.nodes]; // in case order changes while resizing one\n      this.batchUpdate();\n      nodes.forEach(n => {\n        if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\n      });\n      this.batchUpdate(false);\n    }\n    // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize\n    if (this._gsEventHandler['resizecontent']) this._gsEventHandler['resizecontent'](null, n ? [n] : this.engine.nodes);\n  }\n  /** add or remove the grid element size event handler */\n  _updateResizeEvent(forceRemove = false) {\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting dynamic column (i.e. doing work)\n    // or supporting new sizeToContent option.\n    const trackSize = !this.parentGridItem && (this._isAutoCellHeight || this.opts.sizeToContent || this.opts.columnOpts || this.engine.nodes.find(n => n.sizeToContent));\n    if (!forceRemove && trackSize && !this.resizeObserver) {\n      this._sizeThrottle = Utils.throttle(() => this.onResize(), this.opts.cellHeightThrottle);\n      this.resizeObserver = new ResizeObserver(() => this._sizeThrottle());\n      this.resizeObserver.observe(this.el);\n      this._skipInitialResize = true; // makeWidget will originally have called on startup\n    } else if ((forceRemove || !trackSize) && this.resizeObserver) {\n      this.resizeObserver.disconnect();\n      delete this.resizeObserver;\n      delete this._sizeThrottle;\n    }\n    return this;\n  }\n  /** @internal convert a potential selector into actual element */\n  static getElement(els = '.grid-stack-item') {\n    return Utils.getElement(els);\n  }\n  /** @internal */\n  static getElements(els = '.grid-stack-item') {\n    return Utils.getElements(els);\n  }\n  /** @internal */\n  static getGridElement(els) {\n    return GridStack.getElement(els);\n  }\n  /** @internal */\n  static getGridElements(els) {\n    return Utils.getElements(els);\n  }\n  /** @internal initialize margin top/bottom/left/right and units */\n  _initMargin() {\n    let data;\n    let margin = 0;\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\n    let margins = [];\n    if (typeof this.opts.margin === 'string') {\n      margins = this.opts.margin.split(' ');\n    }\n    if (margins.length === 2) {\n      // top/bot, left/right like CSS\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\n    } else if (margins.length === 4) {\n      // Clockwise like CSS\n      this.opts.marginTop = margins[0];\n      this.opts.marginRight = margins[1];\n      this.opts.marginBottom = margins[2];\n      this.opts.marginLeft = margins[3];\n    } else {\n      data = Utils.parseHeight(this.opts.margin);\n      this.opts.marginUnit = data.unit;\n      margin = this.opts.margin = data.h;\n    }\n    // see if top/bottom/left/right need to be set as well\n    if (this.opts.marginTop === undefined) {\n      this.opts.marginTop = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginTop);\n      this.opts.marginTop = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginBottom === undefined) {\n      this.opts.marginBottom = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginBottom);\n      this.opts.marginBottom = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginRight === undefined) {\n      this.opts.marginRight = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginRight);\n      this.opts.marginRight = data.h;\n      delete this.opts.margin;\n    }\n    if (this.opts.marginLeft === undefined) {\n      this.opts.marginLeft = margin;\n    } else {\n      data = Utils.parseHeight(this.opts.marginLeft);\n      this.opts.marginLeft = data.h;\n      delete this.opts.margin;\n    }\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\n    }\n    return this;\n  }\n  /* ===========================================================================================\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\n   * ===========================================================================================\n   */\n  /** get the global (but static to this code) DD implementation */\n  static getDD() {\n    return dd;\n  }\n  /**\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\n   * is dynamically create and needs to be set later.\n   * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements\n   * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\n   * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)\n   */\n  static setupDragIn(dragIn, dragInOptions, root = document) {\n    if (dragInOptions?.pause !== undefined) {\n      DDManager.pauseDrag = dragInOptions.pause;\n    }\n    dragInOptions = {\n      ...dragInDefaultOptions,\n      ...(dragInOptions || {})\n    };\n    let els = typeof dragIn === 'string' ? Utils.getElements(dragIn, root) : dragIn;\n    if (els.length) els?.forEach(el => {\n      if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\n    });\n  }\n  /**\n   * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\n   * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\n   * @param els widget or selector to modify.\n   * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.\n   */\n  movable(els, val) {\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    GridStack.getElements(els).forEach(el => {\n      const n = el.gridstackNode;\n      if (!n) return;\n      val ? delete n.noMove : n.noMove = true;\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\n    });\n    return this;\n  }\n  /**\n   * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\n   * @param els  widget or selector to modify\n   * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.\n   */\n  resizable(els, val) {\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\n    GridStack.getElements(els).forEach(el => {\n      let n = el.gridstackNode;\n      if (!n) return;\n      val ? delete n.noResize : n.noResize = true;\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\n    });\n    return this;\n  }\n  /**\n   * Temporarily disables widgets moving/resizing.\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\n   * Note: no-op for static grid\n   * This is a shortcut for:\n   * @example\n   *  grid.enableMove(false);\n   *  grid.enableResize(false);\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  disable(recurse = true) {\n    if (this.opts.staticGrid) return;\n    this.enableMove(false, recurse);\n    this.enableResize(false, recurse);\n    this._triggerEvent('disable');\n    return this;\n  }\n  /**\n   * Re-enables widgets moving/resizing - see disable().\n   * Note: no-op for static grid.\n   * This is a shortcut for:\n   * @example\n   *  grid.enableMove(true);\n   *  grid.enableResize(true);\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enable(recurse = true) {\n    if (this.opts.staticGrid) return;\n    this.enableMove(true, recurse);\n    this.enableResize(true, recurse);\n    this._triggerEvent('enable');\n    return this;\n  }\n  /**\n   * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enableMove(doEnable, recurse = true) {\n    if (this.opts.staticGrid) return this; // can't move a static grid!\n    doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n);\n      if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\n    });\n    return this;\n  }\n  /**\n   * Enables/disables widget resizing. No-op for static grids.\n   * @param recurse true (default) if sub-grids also get updated\n   */\n  enableResize(doEnable, recurse = true) {\n    if (this.opts.staticGrid) return this; // can't size a static grid!\n    doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\n    this.engine.nodes.forEach(n => {\n      this._prepareDragDropByNode(n);\n      if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\n    });\n    return this;\n  }\n  /** @internal removes any drag&drop present (called during destroy) */\n  _removeDD(el) {\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\n    if (el.gridstackNode) {\n      delete el.gridstackNode._initDD; // reset our DD init flag\n    }\n    delete el.ddElement;\n    return this;\n  }\n  /** @internal called to add drag over to support widgets being added externally */\n  _setupAcceptWidget() {\n    // check if we need to disable things\n    if (this.opts.staticGrid || !this.opts.acceptWidgets && !this.opts.removable) {\n      dd.droppable(this.el, 'destroy');\n      return this;\n    }\n    // vars shared across all methods\n    let cellHeight, cellWidth;\n    let onDrag = (event, el, helper) => {\n      let node = el.gridstackNode;\n      if (!node) return;\n      helper = helper || el;\n      // if the element is being dragged from outside, scale it down to match the grid's scale\n      // and slightly adjust its position relative to the mouse\n      if (!node.grid?.el) {\n        // this scales the helper down\n        helper.style.transform = `scale(${1 / this.dragTransform.xScale},${1 / this.dragTransform.yScale})`;\n        // this makes it so that the helper is well positioned relative to the mouse after scaling\n        const helperRect = helper.getBoundingClientRect();\n        helper.style.left = helperRect.x + (this.dragTransform.xScale - 1) * (event.clientX - helperRect.x) / this.dragTransform.xScale + 'px';\n        helper.style.top = helperRect.y + (this.dragTransform.yScale - 1) * (event.clientY - helperRect.y) / this.dragTransform.yScale + 'px';\n        helper.style.transformOrigin = `0px 0px`;\n      }\n      let parent = this.el.getBoundingClientRect();\n      let {\n        top,\n        left\n      } = helper.getBoundingClientRect();\n      left -= parent.left;\n      top -= parent.top;\n      let ui = {\n        position: {\n          top: top * this.dragTransform.xScale,\n          left: left * this.dragTransform.yScale\n        }\n      };\n      if (node._temporaryRemoved) {\n        node.x = Math.max(0, Math.round(left / cellWidth));\n        node.y = Math.max(0, Math.round(top / cellHeight));\n        delete node.autoPosition;\n        this.engine.nodeBoundFix(node);\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\n        if (!this.engine.willItFit(node)) {\n          node.autoPosition = true; // ignore x,y and try for any slot...\n          if (!this.engine.willItFit(node)) {\n            dd.off(el, 'drag'); // stop calling us\n            return; // full grid or can't grow\n          }\n          if (node._willFitPos) {\n            // use the auto position instead #1687\n            Utils.copyPos(node, node._willFitPos);\n            delete node._willFitPos;\n          }\n        }\n        // re-use the existing node dragging method\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\n      } else {\n        // re-use the existing node dragging that does so much of the collision detection\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\n      }\n    };\n    dd.droppable(this.el, {\n      accept: el => {\n        let node = el.gridstackNode;\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\n        if (node?.grid === this) return true;\n        if (!this.opts.acceptWidgets) return false;\n        // check for accept method or class matching\n        let canAccept = true;\n        if (typeof this.opts.acceptWidgets === 'function') {\n          canAccept = this.opts.acceptWidgets(el);\n        } else {\n          let selector = this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets;\n          canAccept = el.matches(selector);\n        }\n        // finally check to make sure we actually have space left #1571\n        if (canAccept && node && this.opts.maxRow) {\n          let n = {\n            w: node.w,\n            h: node.h,\n            minW: node.minW,\n            minH: node.minH\n          }; // only width/height matters and autoPosition\n          canAccept = this.engine.willItFit(n);\n        }\n        return canAccept;\n      }\n    })\n    /**\n     * entering our grid area\n     */.on(this.el, 'dropover', (event, el, helper) => {\n      // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\n      if (node?.grid === this && !node._temporaryRemoved) {\n        // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\n        return false; // prevent parent from receiving msg (which may be a grid as well)\n      }\n      // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\n      if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\n        // console.log('dropover without leave'); // TEST\n        let otherGrid = node.grid;\n        otherGrid._leave(el, helper);\n      }\n      // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\n      cellWidth = this.cellWidth();\n      cellHeight = this.getCellHeight(true);\n      // load any element attributes if we don't have a node\n      if (!node) {\n        node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354\n      }\n      if (!node.grid) {\n        node._isExternal = true;\n        el.gridstackNode = node;\n      }\n      // calculate the grid size based on element outer size\n      helper = helper || el;\n      let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\n      let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\n      // if the item came from another grid, make a copy and save the original info in case we go back there\n      if (node.grid && node.grid !== this) {\n        // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\n        // console.log('dropover cloning node'); // TEST\n        if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\n        el.gridstackNode = node = {\n          ...node,\n          w,\n          h,\n          grid: this\n        };\n        delete node.x;\n        delete node.y;\n        this.engine.cleanupNode(node).nodeBoundFix(node);\n        // restore some internal fields we need after clearing them all\n        node._initDD = node._isExternal =\n        // DOM needs to be re-parented on a drop\n        node._temporaryRemoved = true; // so it can be inserted onDrag below\n      } else {\n        node.w = w;\n        node.h = h;\n        node._temporaryRemoved = true; // so we can insert it\n      }\n      // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\n      this._itemRemoving(node.el, false);\n      dd.on(el, 'drag', onDrag);\n      // make sure this is called at least once when going fast #1578\n      onDrag(event, el, helper);\n      return false; // prevent parent from receiving msg (which may be a grid as well)\n    })\n    /**\n     * Leaving our grid area...\n     */.on(this.el, 'dropout', (event, el, helper) => {\n      // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\n      let node = el.gridstackNode;\n      if (!node) return false;\n      // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\n      // so skip this one if we're not the active grid really..\n      if (!node.grid || node.grid === this) {\n        this._leave(el, helper);\n        // if we were created as temporary nested grid, go back to before state\n        if (this._isTemp) {\n          this.removeAsSubGrid(node);\n        }\n      }\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    })\n    /**\n     * end - releasing the mouse\n     */.on(this.el, 'drop', (event, el, helper) => {\n      let node = el.gridstackNode;\n      // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\n      if (node?.grid === this && !node._isExternal) return false;\n      const wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\n      this.placeholder.remove();\n      // disable animation when replacing a placeholder (already positioned) with actual content\n      const noAnim = wasAdded && this.opts.animate;\n      if (noAnim) this.setAnimation(false);\n      // notify previous grid of removal\n      // console.log('drop delete _gridstackNodeOrig') // TEST\n      let origNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n      if (wasAdded && origNode?.grid && origNode.grid !== this) {\n        let oGrid = origNode.grid;\n        oGrid.engine.removeNodeFromLayoutCache(origNode);\n        oGrid.engine.removedNodes.push(origNode);\n        oGrid._triggerRemoveEvent()._triggerChangeEvent();\n        // if it's an empty sub-grid that got auto-created, nuke it\n        if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\n          oGrid.removeAsSubGrid();\n        }\n      }\n      if (!node) return false;\n      // use existing placeholder node as it's already in our list with drop location\n      if (wasAdded) {\n        this.engine.cleanupNode(node); // removes all internal _xyz values\n        node.grid = this;\n      }\n      delete node.grid._isTemp;\n      dd.off(el, 'drag');\n      // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\n      // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\n      if (helper !== el) {\n        helper.remove();\n        el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\n        if (wasAdded) {\n          el = el.cloneNode(true);\n        }\n      } else {\n        el.remove(); // reduce flicker as we change depth here, and size further down\n        this._removeDD(el);\n      }\n      if (!wasAdded) return false;\n      el.gridstackNode = node;\n      node.el = el;\n      let subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present\n      // @ts-ignore\n      Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\n      Utils.removePositioningStyles(el); // @ts-ignore\n      this.el.appendChild(el); // @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\n      this._prepareElement(el, true, node);\n      if (subGrid) {\n        subGrid.parentGridItem = node;\n        if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\n      }\n      this._updateContainerHeight();\n      this.engine.addedNodes.push(node); // @ts-ignore\n      this._triggerAddEvent(); // @ts-ignore\n      this._triggerChangeEvent();\n      this.engine.endUpdate();\n      if (this._gsEventHandler['dropped']) {\n        this._gsEventHandler['dropped']({\n          ...event,\n          type: 'dropped'\n        }, origNode && origNode.grid ? origNode : undefined, node);\n      }\n      // delay adding animation back\n      if (noAnim) setTimeout(() => this.setAnimation(this.opts.animate));\n      return false; // prevent parent from receiving msg (which may be grid as well)\n    });\n    return this;\n  }\n  /** @internal mark item for removal */\n  _itemRemoving(el, remove) {\n    let node = el ? el.gridstackNode : undefined;\n    if (!node || !node.grid || el.classList.contains(this.opts.removableOptions.decline)) return;\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\n  }\n  /** @internal called to setup a trash drop zone if the user specifies it */\n  _setupRemoveDrop() {\n    if (!this.opts.staticGrid && typeof this.opts.removable === 'string') {\n      let trashEl = document.querySelector(this.opts.removable);\n      if (!trashEl) return this;\n      // only register ONE drop-over/dropout callback for the 'trash', and it will\n      // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\n      // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\n      if (!dd.isDroppable(trashEl)) {\n        dd.droppable(trashEl, this.opts.removableOptions).on(trashEl, 'dropover', (event, el) => this._itemRemoving(el, true)).on(trashEl, 'dropout', (event, el) => this._itemRemoving(el, false));\n      }\n    }\n    return this;\n  }\n  /** @internal prepares the element for drag&drop */\n  _prepareDragDropByNode(node) {\n    let el = node.el;\n    const noMove = node.noMove || this.opts.disableDrag;\n    const noResize = node.noResize || this.opts.disableResize;\n    // check for disabled grid first\n    if (this.opts.staticGrid || noMove && noResize) {\n      if (node._initDD) {\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\n        delete node._initDD;\n      }\n      el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\n      return this;\n    }\n    if (!node._initDD) {\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\n      let cellWidth;\n      let cellHeight;\n      /** called when item starts moving/resizing */\n      let onStartMoving = (event, ui) => {\n        // trigger any 'dragstart' / 'resizestart' manually\n        if (this._gsEventHandler[event.type]) {\n          this._gsEventHandler[event.type](event, event.target);\n        }\n        cellWidth = this.cellWidth();\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when item is being dragged/resized */\n      let dragOrResize = (event, ui) => {\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\n      };\n      /** called when the item stops moving/resizing */\n      let onEndMoving = event => {\n        this.placeholder.remove();\n        delete node._moving;\n        delete node._event;\n        delete node._lastTried;\n        const widthChanged = node.w !== node._orig.w;\n        // if the item has moved to another grid, we're done here\n        let target = event.target;\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\n        node.el = target;\n        if (node._isAboutToRemove) {\n          let grid = el.gridstackNode.grid;\n          if (grid._gsEventHandler[event.type]) {\n            grid._gsEventHandler[event.type](event, target);\n          }\n          grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\n          grid.removeWidget(el, true, true);\n        } else {\n          Utils.removePositioningStyles(target);\n          if (node._temporaryRemoved) {\n            // got removed - restore item back to before dragging position\n            Utils.copyPos(node, node._orig); // @ts-ignore\n            this._writePosAttr(target, node);\n            this.engine.addNode(node);\n          } else {\n            // move to new placeholder location\n            this._writePosAttr(target, node);\n          }\n          if (this._gsEventHandler[event.type]) {\n            this._gsEventHandler[event.type](event, target);\n          }\n        }\n        // @ts-ignore\n        this._extraDragRow = 0; // @ts-ignore\n        this._updateContainerHeight(); // @ts-ignore\n        this._triggerChangeEvent();\n        this.engine.endUpdate();\n        if (event.type === 'resizestop') {\n          if (Number.isInteger(node.sizeToContent)) node.sizeToContent = node.h; // new soft limit\n          this.resizeToContentCheck(widthChanged, node); // wait for width animation if changed\n        }\n      };\n      dd.draggable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        drag: dragOrResize\n      }).resizable(el, {\n        start: onStartMoving,\n        stop: onEndMoving,\n        resize: dragOrResize\n      });\n      node._initDD = true; // we've set DD support now\n    }\n    // finally fine tune move vs resize by disabling any part...\n    dd.draggable(el, noMove ? 'disable' : 'enable').resizable(el, noResize ? 'disable' : 'enable');\n    return this;\n  }\n  /** @internal handles actual drag/resize start */\n  _onStartMoving(el, event, ui, node, cellWidth, cellHeight) {\n    this.engine.cleanNodes().beginUpdate(node);\n    // @ts-ignore\n    this._writePosAttr(this.placeholder, node);\n    this.el.appendChild(this.placeholder);\n    // console.log('_onStartMoving placeholder') // TEST\n    // if the element is inside a grid, it has already been scaled\n    // we can use that as a scale reference\n    if (node.grid?.el) {\n      this.dragTransform = Utils.getValuesFromTransformedElement(el);\n    }\n    // if the element is being dragged from outside (not from any grid)\n    // we use the grid as the transformation reference, since the helper is not subject to transformation\n    else if (this.placeholder && this.placeholder.closest('.grid-stack')) {\n      const gridEl = this.placeholder.closest('.grid-stack');\n      this.dragTransform = Utils.getValuesFromTransformedElement(gridEl);\n    }\n    // Fallback\n    else {\n      this.dragTransform = {\n        xScale: 1,\n        xOffset: 0,\n        yScale: 1,\n        yOffset: 0\n      };\n    }\n    node.el = this.placeholder;\n    node._lastUiPosition = ui.position;\n    node._prevYPix = ui.position.top;\n    node._moving = event.type === 'dragstart'; // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\n    delete node._lastTried;\n    if (event.type === 'dropover' && node._temporaryRemoved) {\n      // console.log('engine.addNode x=' + node.x); // TEST\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\n    }\n    // set the min/max resize info\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop, this.opts.marginRight, this.opts.marginBottom, this.opts.marginLeft);\n    if (event.type === 'resizestart') {\n      dd.resizable(el, 'option', 'minWidth', cellWidth * (node.minW || 1)).resizable(el, 'option', 'minHeight', cellHeight * (node.minH || 1));\n      if (node.maxW) {\n        dd.resizable(el, 'option', 'maxWidth', cellWidth * node.maxW);\n      }\n      if (node.maxH) {\n        dd.resizable(el, 'option', 'maxHeight', cellHeight * node.maxH);\n      }\n    }\n  }\n  /** @internal handles actual drag/resize */\n  _dragOrResize(el, event, ui, node, cellWidth, cellHeight) {\n    let p = {\n      ...node._orig\n    }; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\n    let resizing;\n    let mLeft = this.opts.marginLeft,\n      mRight = this.opts.marginRight,\n      mTop = this.opts.marginTop,\n      mBottom = this.opts.marginBottom;\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\n    let mHeight = Math.round(cellHeight * 0.1),\n      mWidth = Math.round(cellWidth * 0.1);\n    mLeft = Math.min(mLeft, mWidth);\n    mRight = Math.min(mRight, mWidth);\n    mTop = Math.min(mTop, mHeight);\n    mBottom = Math.min(mBottom, mHeight);\n    if (event.type === 'drag') {\n      if (node._temporaryRemoved) return; // handled by dropover\n      let distance = ui.position.top - node._prevYPix;\n      node._prevYPix = ui.position.top;\n      if (this.opts.draggable.scroll !== false) {\n        Utils.updateScrollPosition(el, ui.position, distance);\n      }\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\n      let left = ui.position.left + (ui.position.left > node._lastUiPosition.left ? -mRight : mLeft);\n      let top = ui.position.top + (ui.position.top > node._lastUiPosition.top ? -mBottom : mTop);\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\n      let prev = this._extraDragRow;\n      if (this.engine.collide(node, p)) {\n        let row = this.getRow();\n        let extra = Math.max(0, p.y + node.h - row);\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\n          extra = Math.max(0, this.opts.maxRow - row);\n        } // @ts-ignore\n        this._extraDragRow = extra; // @ts-ignore\n      } else this._extraDragRow = 0; // @ts-ignore\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\n      if (node.x === p.x && node.y === p.y) return; // skip same\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\n    } else if (event.type === 'resize') {\n      if (p.x < 0) return;\n      // Scrolling page if needed\n      Utils.updateScrollResize(event, el, cellHeight);\n      // get new size\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\n      if (node.w === p.w && node.h === p.h) return;\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\n      // if we size on left/top side this might move us, so get possible new position as well\n      let left = ui.position.left + mLeft;\n      let top = ui.position.top + mTop;\n      p.x = Math.round(left / cellWidth);\n      p.y = Math.round(top / cellHeight);\n      resizing = true;\n    }\n    node._event = event;\n    node._lastTried = p; // set as last tried (will nuke if we go there)\n    let rect = {\n      x: ui.position.left + mLeft,\n      y: ui.position.top + mTop,\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\n    };\n    if (this.engine.moveNodeCheck(node, {\n      ...p,\n      cellWidth,\n      cellHeight,\n      rect,\n      resizing\n    })) {\n      node._lastUiPosition = ui.position;\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\n      delete node._skipDown;\n      if (resizing && node.subGrid) node.subGrid.onResize();\n      this._extraDragRow = 0; // @ts-ignore\n      this._updateContainerHeight();\n      let target = event.target; // @ts-ignore\n      this._writePosAttr(target, node);\n      if (this._gsEventHandler[event.type]) {\n        this._gsEventHandler[event.type](event, target);\n      }\n    }\n  }\n  /** @internal called when item leaving our area by either cursor dropout event\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\n   * our item to start with else restore prev node values from prev grid it came from.\n   */\n  _leave(el, helper) {\n    let node = el.gridstackNode;\n    if (!node) return;\n    helper = helper || el;\n    // restore the scale of the helper on leave\n    helper.style.transform = 'scale(1)';\n    dd.off(el, 'drag'); // no need to track while being outside\n    // this gets called when cursor leaves and shape is outside, so only do this once\n    if (node._temporaryRemoved) return;\n    node._temporaryRemoved = true;\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\n    if (this.opts.removable === true) {\n      // boolean vs a class string\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\n      this._itemRemoving(el, true);\n    }\n    // finally if item originally came from another grid, but left us, restore things back to prev info\n    if (el._gridstackNodeOrig) {\n      // console.log('leave delete _gridstackNodeOrig') // TEST\n      el.gridstackNode = el._gridstackNodeOrig;\n      delete el._gridstackNodeOrig;\n    } else if (node._isExternal) {\n      // item came from outside (like a toolbar) so nuke any node info\n      delete node.el;\n      delete el.gridstackNode;\n      // and restore all nodes back to original\n      this.engine.restoreInitial();\n    }\n  }\n  // legacy method removed\n  commit() {\n    obsolete(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2');\n    return this;\n  }\n}\n/** parent class for sizing content. defaults to '.grid-stack-item-content' */\nGridStack.resizeToContentParent = '.grid-stack-item-content';\n/** scoping so users can call GridStack.Utils.sort() for example */\nGridStack.Utils = Utils;\n/** scoping so users can call new GridStack.Engine(12) for example */\nGridStack.Engine = GridStackEngine;\nGridStack.GDRev = '10.1.1';\nexport { GridStack };","map":{"version":3,"names":["GridStackEngine","Utils","obsolete","gridDefaults","dragInDefaultOptions","DDGridStack","isTouch","DDManager","dd","GridStack","init","options","elOrString","document","el","getGridElement","console","error","gridstack","cloneDeep","initAll","selector","grids","getGridElements","forEach","push","length","addGrid","parent","opt","grid","opts","children","undefined","load","parentIsGrid","classList","contains","addRemoveCB","doc","implementation","createHTMLDocument","body","innerHTML","class","appendChild","registerEngine","engineClass","placeholder","_placeholder","placeholderChild","createElement","className","placeholderText","add","placeholderClass","itemClass","constructor","_gsEventHandler","_extraDragRow","dragTransform","xScale","yScale","xOffset","yOffset","row","minRow","maxRow","rowAttr","toNumber","getAttribute","column","alwaysShowResizeHandle","_alwaysShowResizeHandle","bk","columnOpts","breakpoints","oldOpts","oneColumnModeDomSort","log","oneColumnSize","disableOneColumnMode","oneSize","oneColumn","find","b","c","w","resp","columnWidth","columnMax","sort","a","defaults","staticGrid","toBool","draggable","handle","handleClass","removableOptions","accept","decline","animate","_initMargin","checkDynamicColumn","rtl","style","direction","grandParent","parentElement","parentGridItem","gridstackNode","subGrid","_isAutoCellHeight","cellHeight","cellHeightUnit","_styleSheetClass","_idSeq","_setStaticClass","engine","getColumn","float","onChange","cbNodes","maxH","nodes","n","Math","max","y","h","_removeDOM","remove","_writePosAttr","_updateStyles","auto","batchUpdate","getGridItems","_prepareElement","setAnimation","subGridDynamic","pauseDrag","pause","_setupRemoveDrop","_setupAcceptWidget","_updateResizeEvent","addWidget","els","isGridStackWidget","x","content","node","arguments","_id","domAttr","_readAttr","prepareNode","_writeAttr","_insertNotAppend","prepend","makeWidget","makeSubGrid","ops","nodeToAdd","saveContent","subGridTemplate","subGridOpts","autoColumn","querySelector","newItem","newItemOpt","_removeDD","removeInternalForSave","_prepareDragDropByNode","transition","update","setTimeout","_moving","_isTemp","_autoColumn","window","simulateMouseEvent","_event","removeAsSubGrid","nodeThatRemoved","pGrid","removeWidget","save","saveGridOpt","saveCB","list","sub","listOrOpt","o","marginBottom","marginTop","marginRight","marginLeft","margin","origShow","removeInternalAndSame","items","addRemove","haveCoord","some","_ignoreLayoutsNodeChange","cacheLayout","prevCB","removed","noAnim","copyNodes","id","item","updateNodes","filter","shouldSizeToContent","nodeBoundFix","autoPosition","findEmptyPosition","samePos","moveNode","forceCollide","removedNodes","flag","_updateContainerHeight","_triggerRemoveEvent","_triggerAddEvent","_triggerChangeEvent","getCellHeight","forcePixel","parseFloat","getComputedStyle","documentElement","fontSize","round","offsetHeight","rows","parseInt","getBoundingClientRect","height","val","marginDiff","cellWidth","data","parseHeight","unit","resizeToContentCheck","_widthOrContainer","forBreakpoint","breakpointForWindow","innerWidth","clientWidth","newColumn","min","i","layout","compact","doSort","oldColumn","columnChanged","Array","from","matches","destroy","removeDOM","offAll","setStatic","removeAll","removeAttribute","parentNode","removeChild","_removeStylesheet","getFloat","getCellFromPixel","position","useDocRelative","box","containerPos","top","scrollTop","left","offsetTop","offsetLeft","relativeLeft","relativeTop","width","rowHeight","floor","getRow","isAreaEmpty","getElement","on","name","callback","indexOf","names","split","noData","event","detail","addEventListener","off","removeEventListener","Object","keys","key","triggerEvent","getElements","removeNode","doAnimate","hasAnimationCSS","updateClass","recurse","warn","m","k","minW","minH","maxW","itemContent","styleInHead","changed","ddChanged","sanitizeMinMax","widthChanged","cleanNodes","beginUpdate","endUpdate","resizeToContent","clientHeight","cell","resizeToContentParent","padding","itemH","wantedH","child","firstElementChild","ceil","softMax","Number","isInteger","sizeToContent","resizeToContentCBCheck","resizeToContentCB","value","isMultiValue","marginUnit","getMargin","willItFit","batchMode","elements","getDirtyNodes","layoutsNodesChange","_triggerEvent","saveInitial","addedNodes","_dirty","type","CustomEvent","bubbles","Event","dispatchEvent","_styles","styleLocation","removeStylesheet","forceUpdate","prefix","createStylesheet","nonce","_max","addCSSRule","bottom","right","getHeight","cssMinHeight","setAttribute","String","removeProperty","triggerAddEvent","addNode","attrs","noResize","noMove","locked","clearDefaultAttr","hasOwnProperty","classes","onResize","prevWidth","_skipInitialResize","delay","forceRemove","trackSize","resizeObserver","_sizeThrottle","throttle","cellHeightThrottle","ResizeObserver","observe","disconnect","margins","getDD","setupDragIn","dragIn","dragInOptions","root","isDraggable","movable","resizable","disable","enableMove","enableResize","enable","doEnable","disableDrag","disableResize","_initDD","ddElement","acceptWidgets","removable","droppable","onDrag","helper","transform","helperRect","clientX","clientY","transformOrigin","ui","_temporaryRemoved","_willFitPos","copyPos","_onStartMoving","_dragOrResize","canAccept","otherGrid","_leave","_isExternal","offsetWidth","_gridstackNodeOrig","cleanupNode","_itemRemoving","wasAdded","origNode","oGrid","removeNodeFromLayoutCache","cloneNode","removePositioningStyles","_isAboutToRemove","trashEl","isDroppable","onStartMoving","target","dragOrResize","onEndMoving","_lastTried","_orig","start","stop","drag","resize","getValuesFromTransformedElement","closest","gridEl","_lastUiPosition","_prevYPix","cacheRects","p","resizing","mLeft","mRight","mTop","mBottom","mHeight","mWidth","distance","scroll","updateScrollPosition","prev","collide","extra","updateScrollResize","size","rect","moveNodeCheck","_skipDown","restoreInitial","commit","Engine","GDRev"],"sources":["/Users/luis01/Desktop/MATINF/Asignaturas/Proyecto_Software/battleship/app_web/frontend/node_modules/gridstack/src/gridstack.ts"],"sourcesContent":["/*!\r\n * GridStack 10.1.1\r\n * https://gridstackjs.com/\r\n *\r\n * Copyright (c) 2021-2022 Alain Dumesny\r\n * see root license https://github.com/gridstack/gridstack.js/tree/master/LICENSE\r\n */\r\nimport { GridStackEngine } from './gridstack-engine';\r\nimport { Utils, HeightData, obsolete, DragTransform } from './utils';\r\nimport { gridDefaults, ColumnOptions, GridItemHTMLElement, GridStackElement, GridStackEventHandlerCallback,\r\n  GridStackNode, GridStackWidget, numberOrString, DDUIData, DDDragInOpt, GridStackPosition, GridStackOptions,\r\n  dragInDefaultOptions, GridStackEventHandler, GridStackNodesHandler, AddRemoveFcn, SaveFcn, CompactOptions, GridStackMoveOpts, ResizeToContentFcn, GridStackDroppedHandler, GridStackElementHandler } from './types';\r\n\r\n/*\r\n * and include D&D by default\r\n * TODO: while we could generate a gridstack-static.js at smaller size - saves about 31k (41k -> 72k)\r\n * I don't know how to generate the DD only code at the remaining 31k to delay load as code depends on Gridstack.ts\r\n * also it caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n */\r\nimport { DDGridStack } from './dd-gridstack';\r\nimport { isTouch } from './dd-touch';\r\nimport { DDManager } from './dd-manager';\r\nimport { DDElementHost } from './dd-element';/** global instance */\r\nconst dd = new DDGridStack;\r\n\r\n// export all dependent file as well to make it easier for users to just import the main file\r\nexport * from './types';\r\nexport * from './utils';\r\nexport * from './gridstack-engine';\r\nexport * from './dd-gridstack';\r\n\r\nexport interface GridHTMLElement extends HTMLElement {\r\n  gridstack?: GridStack; // grid's parent DOM element points back to grid class\r\n}\r\n/** list of possible events, or space separated list of them */\r\nexport type GridStackEvent = 'added' | 'change' | 'disable' | 'drag' | 'dragstart' | 'dragstop' | 'dropped' |\r\n  'enable' | 'removed' | 'resize' | 'resizestart' | 'resizestop' | 'resizecontent';\r\n\r\n/** Defines the coordinates of an object */\r\nexport interface MousePosition {\r\n  top: number;\r\n  left: number;\r\n}\r\n\r\n/** Defines the position of a cell inside the grid*/\r\nexport interface CellPosition {\r\n  x: number;\r\n  y: number;\r\n}\r\n\r\ninterface GridCSSStyleSheet extends CSSStyleSheet {\r\n  _max?: number; // internal tracker of the max # of rows we created\r\n}\r\n\r\n// extend with internal fields we need - TODO: move other items in here\r\ninterface InternalGridStackOptions extends GridStackOptions {\r\n  _alwaysShowResizeHandle?: true | false | 'mobile'; // so we can restore for save\r\n}\r\n\r\n// temporary legacy (<10.x) support\r\ninterface OldOneColumnOpts extends GridStackOptions {\r\n  /** disables the onColumnMode when the grid width is less (default?: false) */\r\n  disableOneColumnMode?: boolean;\r\n  /** minimal width before grid will be shown in one column mode (default?: 768) */\r\n  oneColumnSize?: number;\r\n  /** set to true if you want oneColumnMode to use the DOM order and ignore x,y from normal multi column\r\n   layouts during sorting. This enables you to have custom 1 column layout that differ from the rest. (default?: false) */\r\n  oneColumnModeDomSort?: boolean;\r\n}\r\n\r\n/**\r\n * Main gridstack class - you will need to call `GridStack.init()` first to initialize your grid.\r\n * Note: your grid elements MUST have the following classes for the CSS layout to work:\r\n * @example\r\n * <div class=\"grid-stack\">\r\n *   <div class=\"grid-stack-item\">\r\n *     <div class=\"grid-stack-item-content\">Item 1</div>\r\n *   </div>\r\n * </div>\r\n */\r\nexport class GridStack {\r\n\r\n  /**\r\n   * initializing the HTML element, or selector string, into a grid will return the grid. Calling it again will\r\n   * simply return the existing instance (ignore any passed options). There is also an initAll() version that support\r\n   * multiple grids initialization at once. Or you can use addGrid() to create the entire grid from JSON.\r\n   * @param options grid options (optional)\r\n   * @param elOrString element or CSS selector (first one used) to convert to a grid (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   *\r\n   * Note: the HTMLElement (of type GridHTMLElement) will store a `gridstack: GridStack` value that can be retrieve later\r\n   * let grid = document.querySelector('.grid-stack').gridstack;\r\n   */\r\n  public static init(options: GridStackOptions = {}, elOrString: GridStackElement = '.grid-stack'): GridStack {\r\n    if (typeof document === 'undefined') return null; // temp workaround SSR\r\n    let el = GridStack.getGridElement(elOrString);\r\n    if (!el) {\r\n      if (typeof elOrString === 'string') {\r\n        console.error('GridStack.initAll() no grid was found with selector \"' + elOrString + '\" - element missing or wrong selector ?' +\r\n        '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n      } else {\r\n        console.error('GridStack.init() no grid element was passed.');\r\n      }\r\n      return null;\r\n    }\r\n    if (!el.gridstack) {\r\n      el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n    }\r\n    return el.gridstack\r\n  }\r\n\r\n  /**\r\n   * Will initialize a list of elements (given a selector) and return an array of grids.\r\n   * @param options grid options (optional)\r\n   * @param selector elements selector to convert to grids (default to '.grid-stack' class selector)\r\n   *\r\n   * @example\r\n   * let grids = GridStack.initAll();\r\n   * grids.forEach(...)\r\n   */\r\n  public static initAll(options: GridStackOptions = {}, selector = '.grid-stack'): GridStack[] {\r\n    let grids: GridStack[] = [];\r\n    if (typeof document === 'undefined') return grids; // temp workaround SSR\r\n    GridStack.getGridElements(selector).forEach(el => {\r\n      if (!el.gridstack) {\r\n        el.gridstack = new GridStack(el, Utils.cloneDeep(options));\r\n      }\r\n      grids.push(el.gridstack);\r\n    });\r\n    if (grids.length === 0) {\r\n      console.error('GridStack.initAll() no grid was found with selector \"' + selector + '\" - element missing or wrong selector ?' +\r\n      '\\nNote: \".grid-stack\" is required for proper CSS styling and drag/drop, and is the default selector.');\r\n    }\r\n    return grids;\r\n  }\r\n\r\n  /**\r\n   * call to create a grid with the given options, including loading any children from JSON structure. This will call GridStack.init(), then\r\n   * grid.load() on any passed children (recursively). Great alternative to calling init() if you want entire grid to come from\r\n   * JSON serialized data, including options.\r\n   * @param parent HTML element parent to the grid\r\n   * @param opt grids options used to initialize the grid, and list of children\r\n   */\r\n  public static addGrid(parent: HTMLElement, opt: GridStackOptions = {}): GridStack {\r\n    if (!parent) return null;\r\n\r\n    let el = parent as GridHTMLElement;\r\n    if (el.gridstack) {\r\n      // already a grid - set option and load data\r\n      const grid = el.gridstack;\r\n      if (opt) grid.opts = {...grid.opts, ...opt};\r\n      if (opt.children !== undefined) grid.load(opt.children);\r\n      return grid;\r\n    }\r\n\r\n    // create the grid element, but check if the passed 'parent' already has grid styling and should be used instead\r\n    const parentIsGrid = parent.classList.contains('grid-stack');\r\n    if (!parentIsGrid || GridStack.addRemoveCB) {\r\n      if (GridStack.addRemoveCB) {\r\n        el = GridStack.addRemoveCB(parent, opt, true, true);\r\n      } else {\r\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n        doc.body.innerHTML = `<div class=\"grid-stack ${opt.class || ''}\"></div>`;\r\n        el = doc.body.children[0] as HTMLElement;\r\n        parent.appendChild(el);\r\n      }\r\n    }\r\n\r\n    // create grid class and load any children\r\n    let grid = GridStack.init(opt, el);\r\n    return grid;\r\n  }\r\n\r\n  /** call this method to register your engine instead of the default one.\r\n   * See instead `GridStackOptions.engineClass` if you only need to\r\n   * replace just one instance.\r\n   */\r\n  static registerEngine(engineClass: typeof GridStackEngine): void {\r\n    GridStack.engineClass = engineClass;\r\n  }\r\n\r\n  /**\r\n   * callback method use when new items|grids needs to be created or deleted, instead of the default\r\n   * item: <div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">w.content</div></div>\r\n   * grid: <div class=\"grid-stack\">grid content...</div>\r\n   * add = true: the returned DOM element will then be converted to a GridItemHTMLElement using makeWidget()|GridStack:init().\r\n   * add = false: the item will be removed from DOM (if not already done)\r\n   * grid = true|false for grid vs grid-items\r\n   */\r\n  public static addRemoveCB?: AddRemoveFcn;\r\n\r\n  /**\r\n   * callback during saving to application can inject extra data for each widget, on top of the grid layout properties\r\n   */\r\n  public static saveCB?: SaveFcn;\r\n\r\n  /** callback to use for resizeToContent instead of the built in one */\r\n  public static resizeToContentCB?: ResizeToContentFcn;\r\n  /** parent class for sizing content. defaults to '.grid-stack-item-content' */\r\n  public static resizeToContentParent = '.grid-stack-item-content';\r\n\r\n  /** scoping so users can call GridStack.Utils.sort() for example */\r\n  public static Utils = Utils;\r\n\r\n  /** scoping so users can call new GridStack.Engine(12) for example */\r\n  public static Engine = GridStackEngine;\r\n\r\n  /** engine used to implement non DOM grid functionality */\r\n  public engine: GridStackEngine;\r\n\r\n  /** point to a parent grid item if we're nested (inside a grid-item in between 2 Grids) */\r\n  public parentGridItem?: GridStackNode;\r\n\r\n  protected static engineClass: typeof GridStackEngine;\r\n  protected resizeObserver: ResizeObserver;\r\n\r\n  /** @internal unique class name for our generated CSS style sheet */\r\n  protected _styleSheetClass?: string;\r\n  /** @internal true if we got created by drag over gesture, so we can removed on drag out (temporary) */\r\n  public _isTemp?: boolean;\r\n\r\n  /** @internal create placeholder DIV as needed */\r\n  public get placeholder(): HTMLElement {\r\n    if (!this._placeholder) {\r\n      let placeholderChild = document.createElement('div'); // child so padding match item-content\r\n      placeholderChild.className = 'placeholder-content';\r\n      if (this.opts.placeholderText) {\r\n        placeholderChild.innerHTML = this.opts.placeholderText;\r\n      }\r\n      this._placeholder = document.createElement('div');\r\n      this._placeholder.classList.add(this.opts.placeholderClass, gridDefaults.itemClass, this.opts.itemClass);\r\n      this.placeholder.appendChild(placeholderChild);\r\n    }\r\n    return this._placeholder;\r\n  }\r\n  /** @internal */\r\n  protected _placeholder: HTMLElement;\r\n  /** @internal prevent cached layouts from being updated when loading into small column layouts */\r\n  protected _ignoreLayoutsNodeChange: boolean;\r\n  /** @internal */\r\n  public _gsEventHandler = {};\r\n  /** @internal */\r\n  protected _styles: GridCSSStyleSheet;\r\n  /** @internal flag to keep cells square during resize */\r\n  protected _isAutoCellHeight: boolean;\r\n  /** @internal limit auto cell resizing method */\r\n  protected _sizeThrottle: () => void;\r\n  /** @internal limit auto cell resizing method */\r\n  protected prevWidth: number;\r\n  /** @internal true when loading items to insert first rather than append */\r\n  protected _insertNotAppend: boolean;\r\n  /** @internal extra row added when dragging at the bottom of the grid */\r\n  protected _extraDragRow = 0;\r\n  /** @internal true if nested grid should get column count from our width */\r\n  protected _autoColumn?: boolean;\r\n  /** @internal meant to store the scale of the active grid */\r\n  protected dragTransform: DragTransform = { xScale: 1, yScale: 1, xOffset: 0, yOffset: 0 };\r\n  private _skipInitialResize: boolean;\r\n\r\n  /**\r\n   * Construct a grid item from the given element and options\r\n   * @param el the HTML element tied to this grid after it's been initialized\r\n   * @param opts grid options - public for classes to access, but use methods to modify!\r\n   */\r\n  public constructor(public el: GridHTMLElement, public opts: GridStackOptions = {}) {\r\n    el.gridstack = this;\r\n    opts = opts || {}; // handles null/undefined/0\r\n\r\n    if (!el.classList.contains('grid-stack')) {\r\n      this.el.classList.add('grid-stack');\r\n    }\r\n\r\n    // if row property exists, replace minRow and maxRow instead\r\n    if (opts.row) {\r\n      opts.minRow = opts.maxRow = opts.row;\r\n      delete opts.row;\r\n    }\r\n    let rowAttr = Utils.toNumber(el.getAttribute('gs-row'));\r\n\r\n    // flag only valid in sub-grids (handled by parent, not here)\r\n    if (opts.column === 'auto') {\r\n      delete opts.column;\r\n    }\r\n    // save original setting so we can restore on save\r\n    if (opts.alwaysShowResizeHandle !== undefined) {\r\n      (opts as InternalGridStackOptions)._alwaysShowResizeHandle = opts.alwaysShowResizeHandle;\r\n    }\r\n    let bk = opts.columnOpts?.breakpoints;\r\n    // LEGACY: oneColumnMode stuff changed in v10.x - check if user explicitly set something to convert over\r\n    const oldOpts: OldOneColumnOpts = opts;\r\n    if (oldOpts.oneColumnModeDomSort) {\r\n      delete oldOpts.oneColumnModeDomSort;\r\n      console.log('warning: Gridstack oneColumnModeDomSort no longer supported. Use GridStackOptions.columnOpts instead.')\r\n    }\r\n    if (oldOpts.oneColumnSize || oldOpts.disableOneColumnMode === false) {\r\n      const oneSize = oldOpts.oneColumnSize || 768;\r\n      delete oldOpts.oneColumnSize;\r\n      delete oldOpts.disableOneColumnMode;\r\n      opts.columnOpts = opts.columnOpts || {};\r\n      bk = opts.columnOpts.breakpoints = opts.columnOpts.breakpoints || [];\r\n      let oneColumn = bk.find(b => b.c === 1);\r\n      if (!oneColumn) {\r\n        oneColumn = {c: 1, w: oneSize};\r\n        bk.push(oneColumn, {c: 12, w: oneSize+1});\r\n      } else oneColumn.w = oneSize;\r\n    }\r\n    //...end LEGACY\r\n    // cleanup responsive opts (must have columnWidth | breakpoints) then sort breakpoints by size (so we can match during resize)\r\n    const resp = opts.columnOpts;\r\n    if (resp) {\r\n      if (!resp.columnWidth && !resp.breakpoints?.length) {\r\n        delete opts.columnOpts;\r\n        bk = undefined;\r\n      } else {\r\n        resp.columnMax = resp.columnMax || 12;\r\n      }\r\n    }\r\n    if (bk?.length > 1) bk.sort((a,b) => (b.w || 0) - (a.w || 0));\r\n\r\n    // elements DOM attributes override any passed options (like CSS style) - merge the two together\r\n    let defaults: GridStackOptions = {...Utils.cloneDeep(gridDefaults),\r\n      column: Utils.toNumber(el.getAttribute('gs-column')) || gridDefaults.column,\r\n      minRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-min-row')) || gridDefaults.minRow,\r\n      maxRow: rowAttr ? rowAttr : Utils.toNumber(el.getAttribute('gs-max-row')) || gridDefaults.maxRow,\r\n      staticGrid: Utils.toBool(el.getAttribute('gs-static')) || gridDefaults.staticGrid,\r\n      draggable: {\r\n        handle: (opts.handleClass ? '.' + opts.handleClass : (opts.handle ? opts.handle : '')) || gridDefaults.draggable.handle,\r\n      },\r\n      removableOptions: {\r\n        accept: opts.itemClass || gridDefaults.removableOptions.accept,\r\n        decline: gridDefaults.removableOptions.decline\r\n      },\r\n    };\r\n    if (el.getAttribute('gs-animate')) { // default to true, but if set to false use that instead\r\n      defaults.animate = Utils.toBool(el.getAttribute('gs-animate'))\r\n    }\r\n\r\n    opts = Utils.defaults(opts, defaults);\r\n    this._initMargin(); // part of settings defaults...\r\n\r\n    // Now check if we're loading into 1 column mode FIRST so we don't do un-necessary work (like cellHeight = width / 12 then go 1 column)\r\n    this.checkDynamicColumn();\r\n    this.el.classList.add('gs-' + opts.column);\r\n\r\n    if (opts.rtl === 'auto') {\r\n      opts.rtl = (el.style.direction === 'rtl');\r\n    }\r\n    if (opts.rtl) {\r\n      this.el.classList.add('grid-stack-rtl');\r\n    }\r\n\r\n    // check if we're been nested, and if so update our style and keep pointer around (used during save)\r\n    const grandParent: GridItemHTMLElement = this.el.parentElement?.parentElement;\r\n    let parentGridItem = grandParent?.classList.contains(gridDefaults.itemClass) ? grandParent.gridstackNode : undefined;\r\n    if (parentGridItem) {\r\n      parentGridItem.subGrid = this;\r\n      this.parentGridItem = parentGridItem;\r\n      this.el.classList.add('grid-stack-nested');\r\n      parentGridItem.el.classList.add('grid-stack-sub-grid');\r\n    }\r\n\r\n    this._isAutoCellHeight = (opts.cellHeight === 'auto');\r\n    if (this._isAutoCellHeight || opts.cellHeight === 'initial') {\r\n      // make the cell content square initially (will use resize/column event to keep it square)\r\n      this.cellHeight(undefined, false);\r\n    } else {\r\n      // append unit if any are set\r\n      if (typeof opts.cellHeight == 'number' && opts.cellHeightUnit && opts.cellHeightUnit !== gridDefaults.cellHeightUnit) {\r\n        opts.cellHeight = opts.cellHeight + opts.cellHeightUnit;\r\n        delete opts.cellHeightUnit;\r\n      }\r\n      this.cellHeight(opts.cellHeight, false);\r\n    }\r\n\r\n    // see if we need to adjust auto-hide\r\n    if (opts.alwaysShowResizeHandle === 'mobile') {\r\n      opts.alwaysShowResizeHandle = isTouch;\r\n    }\r\n\r\n    this._styleSheetClass = 'gs-id-' + GridStackEngine._idSeq++;\r\n    this.el.classList.add(this._styleSheetClass);\r\n\r\n    this._setStaticClass();\r\n\r\n    let engineClass = opts.engineClass || GridStack.engineClass || GridStackEngine;\r\n    this.engine = new engineClass({\r\n      column: this.getColumn(),\r\n      float: opts.float,\r\n      maxRow: opts.maxRow,\r\n      onChange: (cbNodes) => {\r\n        let maxH = 0;\r\n        this.engine.nodes.forEach(n => { maxH = Math.max(maxH, n.y + n.h) });\r\n        cbNodes.forEach(n => {\r\n          let el = n.el;\r\n          if (!el) return;\r\n          if (n._removeDOM) {\r\n            if (el) el.remove();\r\n            delete n._removeDOM;\r\n          } else {\r\n            this._writePosAttr(el, n);\r\n          }\r\n        });\r\n        this._updateStyles(false, maxH); // false = don't recreate, just append if need be\r\n      }\r\n    });\r\n\r\n    // create initial global styles BEFORE loading children so resizeToContent margin can be calculated correctly\r\n    this._updateStyles(false, 0);\r\n\r\n    if (opts.auto) {\r\n      this.batchUpdate(); // prevent in between re-layout #1535 TODO: this only set float=true, need to prevent collision check...\r\n      this.getGridItems().forEach(el => this._prepareElement(el));\r\n      this.batchUpdate(false);\r\n    }\r\n\r\n    // load any passed in children as well, which overrides any DOM layout done above\r\n    if (opts.children) {\r\n      let children = opts.children;\r\n      delete opts.children;\r\n      if (children.length) this.load(children); // don't load empty\r\n    }\r\n\r\n    // if (this.engine.nodes.length) this._updateStyles(); // update based on # of children. done in engine onChange CB\r\n    this.setAnimation(opts.animate);\r\n\r\n    // dynamic grids require pausing during drag to detect over to nest vs push\r\n    if (opts.subGridDynamic && !DDManager.pauseDrag) DDManager.pauseDrag = true;\r\n    if (opts.draggable?.pause !== undefined) DDManager.pauseDrag = opts.draggable.pause;\r\n\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this._updateResizeEvent();\r\n  }\r\n\r\n  /**\r\n   * add a new widget and returns it.\r\n   *\r\n   * Widget will be always placed even if result height is more than actual grid height.\r\n   * You need to use `willItFit()` before calling addWidget for additional check.\r\n   * See also `makeWidget()`.\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.addWidget({w: 3, content: 'hello'});\r\n   * grid.addWidget('<div class=\"grid-stack-item\"><div class=\"grid-stack-item-content\">hello</div></div>', {w: 3});\r\n   *\r\n   * @param el  GridStackWidget (which can have content string as well), html element, or string definition to add\r\n   * @param options widget position/size options (optional, and ignore if first param is already option) - see GridStackWidget\r\n   */\r\n  public addWidget(els?: GridStackWidget | GridStackElement, options?: GridStackWidget): GridItemHTMLElement {\r\n    function isGridStackWidget(w: GridStackNode): w is GridStackNode { // https://medium.com/ovrsea/checking-the-type-of-an-object-in-typescript-the-type-guards-24d98d9119b0\r\n      return w.el !== undefined || w.x !== undefined || w.y !== undefined || w.w !== undefined || w.h !== undefined || w.content !== undefined ? true : false;\r\n    }\r\n\r\n    let el: GridItemHTMLElement;\r\n    let node: GridStackNode;\r\n    if (typeof els === 'string') {\r\n      let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n      doc.body.innerHTML = els;\r\n      el = doc.body.children[0] as HTMLElement;\r\n    } else if (arguments.length === 0 || arguments.length === 1 && isGridStackWidget(els)) {\r\n      node = options = els;\r\n      if (node?.el) {\r\n        el = node.el; // re-use element stored in the node\r\n      } else if (GridStack.addRemoveCB) {\r\n        el = GridStack.addRemoveCB(this.el, options, true, false);\r\n      } else {\r\n        let content = options?.content || '';\r\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n        doc.body.innerHTML = `<div class=\"grid-stack-item ${this.opts.itemClass || ''}\"><div class=\"grid-stack-item-content\">${content}</div></div>`;\r\n        el = doc.body.children[0] as HTMLElement;\r\n      }\r\n    } else {\r\n      el = els as HTMLElement;\r\n    }\r\n\r\n    if (!el) return;\r\n\r\n    // if the caller ended up initializing the widget in addRemoveCB, or we stared with one already, skip the rest\r\n    node = el.gridstackNode;\r\n    if (node && el.parentElement === this.el && this.engine.nodes.find(n => n._id === node._id)) return el;\r\n\r\n    // Tempting to initialize the passed in opt with default and valid values, but this break knockout demos\r\n    // as the actual value are filled in when _prepareElement() calls el.getAttribute('gs-xyz') before adding the node.\r\n    // So make sure we load any DOM attributes that are not specified in passed in options (which override)\r\n    let domAttr = this._readAttr(el);\r\n    options = Utils.cloneDeep(options) || {};  // make a copy before we modify in case caller re-uses it\r\n    Utils.defaults(options, domAttr);\r\n    node = this.engine.prepareNode(options);\r\n    this._writeAttr(el, options);\r\n\r\n    if (this._insertNotAppend) {\r\n      this.el.prepend(el);\r\n    } else {\r\n      this.el.appendChild(el);\r\n    }\r\n\r\n    this.makeWidget(el, options);\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Convert an existing gridItem element into a sub-grid with the given (optional) options, else inherit them\r\n   * from the parent's subGrid options.\r\n   * @param el gridItem element to convert\r\n   * @param ops (optional) sub-grid options, else default to node, then parent settings, else defaults\r\n   * @param nodeToAdd (optional) node to add to the newly created sub grid (used when dragging over existing regular item)\r\n   * @param saveContent if true (default) the html inside .grid-stack-content will be saved to child widget\r\n   * @returns newly created grid\r\n   */\r\n  public makeSubGrid(el: GridItemHTMLElement, ops?: GridStackOptions, nodeToAdd?: GridStackNode, saveContent = true): GridStack {\r\n    let node = el.gridstackNode;\r\n    if (!node) {\r\n      node = this.makeWidget(el).gridstackNode;\r\n    }\r\n    if (node.subGrid?.el) return node.subGrid; // already done\r\n\r\n    // find the template subGrid stored on a parent as fallback...\r\n    let subGridTemplate: GridStackOptions; // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n    let grid: GridStack = this;\r\n    while (grid && !subGridTemplate) {\r\n      subGridTemplate = grid.opts?.subGridOpts;\r\n      grid = grid.parentGridItem?.grid;\r\n    }\r\n    //... and set the create options\r\n    ops = Utils.cloneDeep({...(subGridTemplate || {}), children: undefined, ...(ops || node.subGridOpts || {})});\r\n    node.subGridOpts = ops;\r\n\r\n    // if column special case it set, remember that flag and set default\r\n    let autoColumn: boolean;\r\n    if (ops.column === 'auto') {\r\n      autoColumn = true;\r\n      ops.column = Math.max(node.w || 1, nodeToAdd?.w || 1);\r\n      delete ops.columnOpts; // driven by parent\r\n    }\r\n\r\n    // if we're converting an existing full item, move over the content to be the first sub item in the new grid\r\n    let content = node.el.querySelector('.grid-stack-item-content') as HTMLElement;\r\n    let newItem: HTMLElement;\r\n    let newItemOpt: GridStackNode;\r\n    if (saveContent) {\r\n      this._removeDD(node.el); // remove D&D since it's set on content div\r\n      newItemOpt = {...node, x:0, y:0};\r\n      Utils.removeInternalForSave(newItemOpt);\r\n      delete newItemOpt.subGridOpts;\r\n      if (node.content) {\r\n        newItemOpt.content = node.content;\r\n        delete node.content;\r\n      }\r\n      if (GridStack.addRemoveCB) {\r\n        newItem = GridStack.addRemoveCB(this.el, newItemOpt, true, false);\r\n      } else {\r\n        let doc = document.implementation.createHTMLDocument(''); // IE needs a param\r\n        doc.body.innerHTML = `<div class=\"grid-stack-item\"></div>`;\r\n        newItem = doc.body.children[0] as HTMLElement;\r\n        newItem.appendChild(content);\r\n        doc.body.innerHTML = `<div class=\"grid-stack-item-content\"></div>`;\r\n        content = doc.body.children[0] as HTMLElement;\r\n        node.el.appendChild(content);\r\n      }\r\n      this._prepareDragDropByNode(node); // ... and restore original D&D\r\n    }\r\n\r\n    // if we're adding an additional item, make the container large enough to have them both\r\n    if (nodeToAdd) {\r\n      let w = autoColumn ? ops.column : node.w;\r\n      let h = node.h + nodeToAdd.h;\r\n      let style = node.el.style;\r\n      style.transition = 'none'; // show up instantly so we don't see scrollbar with nodeToAdd\r\n      this.update(node.el, {w, h});\r\n      setTimeout(() =>  style.transition = null); // recover animation\r\n    }\r\n\r\n    let subGrid = node.subGrid = GridStack.addGrid(content, ops);\r\n    if (nodeToAdd?._moving) subGrid._isTemp = true; // prevent re-nesting as we add over\r\n    if (autoColumn) subGrid._autoColumn = true;\r\n\r\n    // add the original content back as a child of hte newly created grid\r\n    if (saveContent) {\r\n      subGrid.addWidget(newItem, newItemOpt);\r\n    }\r\n\r\n    // now add any additional node\r\n    if (nodeToAdd) {\r\n      if (nodeToAdd._moving) {\r\n        // create an artificial event even for the just created grid to receive this item\r\n        window.setTimeout(() => Utils.simulateMouseEvent(nodeToAdd._event, 'mouseenter', subGrid.el), 0);\r\n      } else {\r\n        subGrid.addWidget(node.el, node);\r\n      }\r\n    }\r\n    return subGrid;\r\n  }\r\n\r\n  /**\r\n   * called when an item was converted into a nested grid to accommodate a dragged over item, but then item leaves - return back\r\n   * to the original grid-item. Also called to remove empty sub-grids when last item is dragged out (since re-creating is simple)\r\n   */\r\n  public removeAsSubGrid(nodeThatRemoved?: GridStackNode): void {\r\n    let pGrid = this.parentGridItem?.grid;\r\n    if (!pGrid) return;\r\n\r\n    pGrid.batchUpdate();\r\n    pGrid.removeWidget(this.parentGridItem.el, true, true);\r\n    this.engine.nodes.forEach(n => {\r\n      // migrate any children over and offsetting by our location\r\n      n.x += this.parentGridItem.x;\r\n      n.y += this.parentGridItem.y;\r\n      pGrid.addWidget(n.el, n);\r\n    });\r\n    pGrid.batchUpdate(false);\r\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\r\n    delete this.parentGridItem;\r\n\r\n    // create an artificial event for the original grid now that this one is gone (got a leave, but won't get enter)\r\n    if (nodeThatRemoved) {\r\n      window.setTimeout(() => Utils.simulateMouseEvent(nodeThatRemoved._event, 'mouseenter', pGrid.el), 0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * saves the current layout returning a list of widgets for serialization which might include any nested grids.\r\n   * @param saveContent if true (default) the latest html inside .grid-stack-content will be saved to GridStackWidget.content field, else it will\r\n   * be removed.\r\n   * @param saveGridOpt if true (default false), save the grid options itself, so you can call the new GridStack.addGrid()\r\n   * to recreate everything from scratch. GridStackOptions.children would then contain the widget list instead.\r\n   * @param saveCB callback for each node -> widget, so application can insert additional data to be saved into the widget data structure.\r\n   * @returns list of widgets or full grid option, including .children list of widgets\r\n   */\r\n  public save(saveContent = true, saveGridOpt = false, saveCB = GridStack.saveCB): GridStackWidget[] | GridStackOptions {\r\n    // return copied GridStackWidget (with optionally .el) we can modify at will...\r\n    let list = this.engine.save(saveContent, saveCB);\r\n\r\n    // check for HTML content and nested grids\r\n    list.forEach(n => {\r\n      if (saveContent && n.el && !n.subGrid && !saveCB) { // sub-grid are saved differently, not plain content\r\n        let sub = n.el.querySelector('.grid-stack-item-content');\r\n        n.content = sub ? sub.innerHTML : undefined;\r\n        if (!n.content) delete n.content;\r\n      } else {\r\n        if (!saveContent && !saveCB) { delete n.content; }\r\n        // check for nested grid\r\n        if (n.subGrid?.el) {\r\n          const listOrOpt = n.subGrid.save(saveContent, saveGridOpt, saveCB);\r\n          n.subGridOpts = (saveGridOpt ? listOrOpt : {children: listOrOpt}) as GridStackOptions;\r\n          delete n.subGrid;\r\n        }\r\n      }\r\n      delete n.el;\r\n    });\r\n\r\n    // check if save entire grid options (needed for recursive) + children...\r\n    if (saveGridOpt) {\r\n      let o: InternalGridStackOptions = Utils.cloneDeep(this.opts);\r\n      // delete default values that will be recreated on launch\r\n      if (o.marginBottom === o.marginTop && o.marginRight === o.marginLeft && o.marginTop === o.marginRight) {\r\n        o.margin = o.marginTop;\r\n        delete o.marginTop; delete o.marginRight; delete o.marginBottom; delete o.marginLeft;\r\n      }\r\n      if (o.rtl === (this.el.style.direction === 'rtl')) { o.rtl = 'auto' }\r\n      if (this._isAutoCellHeight) {\r\n        o.cellHeight = 'auto'\r\n      }\r\n      if (this._autoColumn) {\r\n        o.column = 'auto';\r\n      }\r\n      const origShow = o._alwaysShowResizeHandle;\r\n      delete o._alwaysShowResizeHandle;\r\n      if (origShow !== undefined) {\r\n        o.alwaysShowResizeHandle = origShow;\r\n      } else {\r\n        delete o.alwaysShowResizeHandle;\r\n      }\r\n      Utils.removeInternalAndSame(o, gridDefaults);\r\n      o.children = list;\r\n      return o;\r\n    }\r\n\r\n    return list;\r\n  }\r\n\r\n  /**\r\n   * load the widgets from a list. This will call update() on each (matching by id) or add/remove widgets that are not there.\r\n   *\r\n   * @param layout list of widgets definition to update/create\r\n   * @param addAndRemove boolean (default true) or callback method can be passed to control if and how missing widgets can be added/removed, giving\r\n   * the user control of insertion.\r\n   *\r\n   * @example\r\n   * see http://gridstackjs.com/demo/serialization.html\r\n   */\r\n  public load(items: GridStackWidget[], addRemove: boolean | AddRemoveFcn = GridStack.addRemoveCB || true): GridStack {\r\n    items = Utils.cloneDeep(items); // so we can mod\r\n    const column = this.getColumn();\r\n\r\n    // if passed list has coordinates, use them (insert from end to beginning for conflict resolution) else keep widget order\r\n    const haveCoord = items.some(w => w.x !== undefined || w.y !== undefined);\r\n    if (haveCoord) items = Utils.sort(items, -1, column);\r\n    this._insertNotAppend = haveCoord; // if we create in reverse order...\r\n\r\n    // if we're loading a layout into for example 1 column and items don't fit, make sure to save\r\n    // the original wanted layout so we can scale back up correctly #1471\r\n    if (items.some(n => ((n.x || 0) + (n.w || 1)) > column)) {\r\n      this._ignoreLayoutsNodeChange = true; // skip layout update\r\n      this.engine.cacheLayout(items, 12, true); // TODO: 12 is arbitrary. use max value in layout ?\r\n    }\r\n\r\n    // if given a different callback, temporally set it as global option so creating will use it\r\n    const prevCB = GridStack.addRemoveCB;\r\n    if (typeof(addRemove) === 'function') GridStack.addRemoveCB = addRemove as AddRemoveFcn;\r\n\r\n    let removed: GridStackNode[] = [];\r\n    this.batchUpdate();\r\n\r\n    // if we are blank (loading into empty like startup) temp remove animation\r\n    const noAnim = !this.engine.nodes.length;\r\n    if (noAnim) this.setAnimation(false);\r\n\r\n    // see if any items are missing from new layout and need to be removed first\r\n    if (addRemove) {\r\n      let copyNodes = [...this.engine.nodes]; // don't loop through array you modify\r\n      copyNodes.forEach(n => {\r\n        if (!n.id) return;\r\n        let item = Utils.find(items, n.id);\r\n        if (!item) {\r\n          if (GridStack.addRemoveCB)\r\n            GridStack.addRemoveCB(this.el, n, false, false);\r\n          removed.push(n); // batch keep track\r\n          this.removeWidget(n.el, true, false);\r\n        }\r\n      });\r\n    }\r\n\r\n    // now add/update the widgets - starting with removing items in the new layout we will reposition\r\n    // to reduce collision and add no-coord ones at next available spot\r\n    let updateNodes: GridStackWidget[] = [];\r\n    this.engine.nodes = this.engine.nodes.filter(n => {\r\n      if (Utils.find(items, n.id)) { updateNodes.push(n); return false; } // remove if found from list\r\n      return true;\r\n    });\r\n    items.forEach(w => {\r\n      let item = Utils.find(updateNodes, w.id);\r\n      if (item) {\r\n        // if item sizes to content, re-use the exiting height so it's a better guess at the final size (same if width doesn't change)\r\n        if (Utils.shouldSizeToContent(item)) w.h = item.h;\r\n        // check if missing coord, in which case find next empty slot with new (or old if missing) sizes\r\n        this.engine.nodeBoundFix(w);\r\n        if (w.autoPosition || w.x === undefined || w.y === undefined) {\r\n          w.w = w.w || item.w;\r\n          w.h = w.h || item.h;\r\n          this.engine.findEmptyPosition(w);\r\n        }\r\n\r\n        // add back to current list BUT force a collision check if it 'appears' we didn't change to make sure we don't overlap others now\r\n        this.engine.nodes.push(item);\r\n        if (Utils.samePos(item, w)) {\r\n          this.moveNode(item, {...w, forceCollide: true});\r\n        }\r\n\r\n        this.update(item.el, w);\r\n        if (w.subGridOpts?.children) { // update any sub grid as well\r\n          let sub = item.el.querySelector('.grid-stack') as GridHTMLElement;\r\n          if (sub && sub.gridstack) {\r\n            sub.gridstack.load(w.subGridOpts.children); // TODO: support updating grid options ?\r\n            this._insertNotAppend = true; // got reset by above call\r\n          }\r\n        }\r\n      } else if (addRemove) {\r\n        this.addWidget(w);\r\n      }\r\n    });\r\n\r\n    this.engine.removedNodes = removed;\r\n    this.batchUpdate(false);\r\n\r\n    // after commit, clear that flag\r\n    delete this._ignoreLayoutsNodeChange;\r\n    delete this._insertNotAppend;\r\n    prevCB ? GridStack.addRemoveCB = prevCB : delete GridStack.addRemoveCB;\r\n    // delay adding animation back\r\n    if (noAnim && this.opts.animate) setTimeout(() => this.setAnimation(this.opts.animate));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * use before calling a bunch of `addWidget()` to prevent un-necessary relayouts in between (more efficient)\r\n   * and get a single event callback. You will see no changes until `batchUpdate(false)` is called.\r\n   */\r\n  public batchUpdate(flag = true): GridStack {\r\n    this.engine.batchUpdate(flag);\r\n    if (!flag) {\r\n      this._updateContainerHeight();\r\n      this._triggerRemoveEvent();\r\n      this._triggerAddEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Gets current cell height.\r\n   */\r\n  public getCellHeight(forcePixel = false): number {\r\n    if (this.opts.cellHeight && this.opts.cellHeight !== 'auto' &&\r\n       (!forcePixel || !this.opts.cellHeightUnit || this.opts.cellHeightUnit === 'px')) {\r\n      return this.opts.cellHeight as number;\r\n    }\r\n    // do rem/em/cm/mm to px conversion\r\n    if (this.opts.cellHeightUnit === 'rem') {\r\n      return (this.opts.cellHeight as number) * parseFloat(getComputedStyle(document.documentElement).fontSize);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'em') {\r\n      return (this.opts.cellHeight as number) * parseFloat(getComputedStyle(this.el).fontSize);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'cm') {\r\n      // 1cm = 96px/2.54. See https://www.w3.org/TR/css-values-3/#absolute-lengths\r\n      return (this.opts.cellHeight as number) * (96 / 2.54);\r\n    }\r\n    if (this.opts.cellHeightUnit === 'mm') {\r\n      return (this.opts.cellHeight as number) * (96 / 2.54) / 10;\r\n    }\r\n    // else get first cell height\r\n    let el = this.el.querySelector('.' + this.opts.itemClass) as HTMLElement;\r\n    if (el) {\r\n      let h = Utils.toNumber(el.getAttribute('gs-h')) || 1; // since we don't write 1 anymore\r\n      return Math.round(el.offsetHeight / h);\r\n    }\r\n    // else do entire grid and # of rows (but doesn't work if min-height is the actual constrain)\r\n    let rows = parseInt(this.el.getAttribute('gs-current-row'));\r\n    return rows ? Math.round(this.el.getBoundingClientRect().height / rows) : this.opts.cellHeight as number;\r\n  }\r\n\r\n  /**\r\n   * Update current cell height - see `GridStackOptions.cellHeight` for format.\r\n   * This method rebuilds an internal CSS style sheet.\r\n   * Note: You can expect performance issues if call this method too often.\r\n   *\r\n   * @param val the cell height. If not passed (undefined), cells content will be made square (match width minus margin),\r\n   * if pass 0 the CSS will be generated by the application instead.\r\n   * @param update (Optional) if false, styles will not be updated\r\n   *\r\n   * @example\r\n   * grid.cellHeight(100); // same as 100px\r\n   * grid.cellHeight('70px');\r\n   * grid.cellHeight(grid.cellWidth() * 1.2);\r\n   */\r\n  public cellHeight(val?: numberOrString, update = true): GridStack {\r\n\r\n    // if not called internally, check if we're changing mode\r\n    if (update && val !== undefined) {\r\n      if (this._isAutoCellHeight !== (val === 'auto')) {\r\n        this._isAutoCellHeight = (val === 'auto');\r\n        this._updateResizeEvent();\r\n      }\r\n    }\r\n    if (val === 'initial' || val === 'auto') { val = undefined; }\r\n\r\n    // make item content be square\r\n    if (val === undefined) {\r\n      let marginDiff = - (this.opts.marginRight as number) - (this.opts.marginLeft as number)\r\n        + (this.opts.marginTop as number) + (this.opts.marginBottom as number);\r\n      val = this.cellWidth() + marginDiff;\r\n    }\r\n\r\n    let data = Utils.parseHeight(val);\r\n    if (this.opts.cellHeightUnit === data.unit && this.opts.cellHeight === data.h) {\r\n      return this;\r\n    }\r\n    this.opts.cellHeightUnit = data.unit;\r\n    this.opts.cellHeight = data.h;\r\n\r\n    this.resizeToContentCheck();\r\n\r\n    if (update) {\r\n      this._updateStyles(true); // true = force re-create for current # of rows\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** Gets current cell width. */\r\n  public cellWidth(): number {\r\n    return this._widthOrContainer() / this.getColumn();\r\n  }\r\n  /** return our expected width (or parent) , and optionally of window for dynamic column check */\r\n  protected _widthOrContainer(forBreakpoint = false): number {\r\n    // use `offsetWidth` or `clientWidth` (no scrollbar) ?\r\n    // https://stackoverflow.com/questions/21064101/understanding-offsetwidth-clientwidth-scrollwidth-and-height-respectively\r\n    return forBreakpoint && this.opts.columnOpts?.breakpointForWindow ? window.innerWidth : (this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth);\r\n  }\r\n  /** checks for dynamic column count for our current size, returning true if changed */\r\n  protected checkDynamicColumn(): boolean {\r\n    const resp = this.opts.columnOpts;\r\n    if (!resp || (!resp.columnWidth && !resp.breakpoints?.length)) return false;\r\n    const column = this.getColumn();\r\n    let newColumn = column;\r\n    const w = this._widthOrContainer(true);\r\n    if (resp.columnWidth) {\r\n      newColumn = Math.min(Math.round(w / resp.columnWidth) || 1, resp.columnMax);\r\n    } else {\r\n      // find the closest breakpoint (already sorted big to small) that matches\r\n      newColumn = resp.columnMax;\r\n      let i = 0;\r\n      while (i < resp.breakpoints.length && w <= resp.breakpoints[i].w) {\r\n        newColumn = resp.breakpoints[i++].c || column;\r\n      }\r\n    }\r\n    if (newColumn !== column) {\r\n      const bk = resp.breakpoints?.find(b => b.c === newColumn);\r\n      this.column(newColumn, bk?.layout || resp.layout);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * re-layout grid items to reclaim any empty space. Options are:\r\n   * 'list' keep the widget left->right order the same, even if that means leaving an empty slot if things don't fit\r\n   * 'compact' might re-order items to fill any empty space\r\n   *\r\n   * doSort - 'false' to let you do your own sorting ahead in case you need to control a different order. (default to sort)\r\n   */\r\n  public compact(layout: CompactOptions = 'compact', doSort = true): GridStack {\r\n    this.engine.compact(layout, doSort);\r\n    this._triggerChangeEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * set the number of columns in the grid. Will update existing widgets to conform to new number of columns,\r\n   * as well as cache the original layout so you can revert back to previous positions without loss.\r\n   * Requires `gridstack-extra.css` or `gridstack-extra.min.css` for [2-11],\r\n   * else you will need to generate correct CSS (see https://github.com/gridstack/gridstack.js#change-grid-columns)\r\n   * @param column - Integer > 0 (default 12).\r\n   * @param layout specify the type of re-layout that will happen (position, size, etc...).\r\n   * Note: items will never be outside of the current column boundaries. default ('moveScale'). Ignored for 1 column\r\n   */\r\n  public column(column: number, layout: ColumnOptions = 'moveScale'): GridStack {\r\n    if (!column || column < 1 || this.opts.column === column) return this;\r\n\r\n    let oldColumn = this.getColumn();\r\n    this.opts.column = column;\r\n    if (!this.engine) return this; // called in constructor, noting else to do\r\n\r\n    this.engine.column = column;\r\n    this.el.classList.remove('gs-' + oldColumn);\r\n    this.el.classList.add('gs-' + column);\r\n\r\n    // update the items now, checking if we have a custom children layout\r\n    /*const newChildren = this.opts.columnOpts?.breakpoints?.find(r => r.c === column)?.children;\r\n    if (newChildren) this.load(newChildren);\r\n    else*/ this.engine.columnChanged(oldColumn, column, layout);\r\n    if (this._isAutoCellHeight) this.cellHeight();\r\n\r\n    this.resizeToContentCheck(true); // wait for width resizing\r\n\r\n    // and trigger our event last...\r\n    this._ignoreLayoutsNodeChange = true; // skip layout update\r\n    this._triggerChangeEvent();\r\n    delete this._ignoreLayoutsNodeChange;\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * get the number of columns in the grid (default 12)\r\n   */\r\n  public getColumn(): number { return this.opts.column as number; }\r\n\r\n  /** returns an array of grid HTML elements (no placeholder) - used to iterate through our children in DOM order */\r\n  public getGridItems(): GridItemHTMLElement[] {\r\n    return Array.from(this.el.children)\r\n      .filter((el: HTMLElement) => el.matches('.' + this.opts.itemClass) && !el.matches('.' + this.opts.placeholderClass)) as GridItemHTMLElement[];\r\n  }\r\n\r\n  /**\r\n   * Destroys a grid instance. DO NOT CALL any methods or access any vars after this as it will free up members.\r\n   * @param removeDOM if `false` grid and items HTML elements will not be removed from the DOM (Optional. Default `true`).\r\n   */\r\n  public destroy(removeDOM = true): GridStack {\r\n    if (!this.el) return; // prevent multiple calls\r\n    this.offAll();\r\n    this._updateResizeEvent(true);\r\n    this.setStatic(true, false); // permanently removes DD but don't set CSS class (we're going away)\r\n    this.setAnimation(false);\r\n    if (!removeDOM) {\r\n      this.removeAll(removeDOM);\r\n      this.el.classList.remove(this._styleSheetClass);\r\n      this.el.removeAttribute('gs-current-row');\r\n    } else {\r\n      this.el.parentNode.removeChild(this.el);\r\n    }\r\n    this._removeStylesheet();\r\n    if (this.parentGridItem) delete this.parentGridItem.subGrid;\r\n    delete this.parentGridItem;\r\n    delete this.opts;\r\n    delete this._placeholder;\r\n    delete this.engine;\r\n    delete this.el.gridstack; // remove circular dependency that would prevent a freeing\r\n    delete this.el;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * enable/disable floating widgets (default: `false`) See [example](http://gridstackjs.com/demo/float.html)\r\n   */\r\n  public float(val: boolean): GridStack {\r\n    if (this.opts.float !== val) {\r\n      this.opts.float = this.engine.float = val;\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * get the current float mode\r\n   */\r\n  public getFloat(): boolean {\r\n    return this.engine.float;\r\n  }\r\n\r\n  /**\r\n   * Get the position of the cell under a pixel on screen.\r\n   * @param position the position of the pixel to resolve in\r\n   * absolute coordinates, as an object with top and left properties\r\n   * @param useDocRelative if true, value will be based on document position vs parent position (Optional. Default false).\r\n   * Useful when grid is within `position: relative` element\r\n   *\r\n   * Returns an object with properties `x` and `y` i.e. the column and row in the grid.\r\n   */\r\n  public getCellFromPixel(position: MousePosition, useDocRelative = false): CellPosition {\r\n    let box = this.el.getBoundingClientRect();\r\n    // console.log(`getBoundingClientRect left: ${box.left} top: ${box.top} w: ${box.w} h: ${box.h}`)\r\n    let containerPos: {top: number, left: number};\r\n    if (useDocRelative) {\r\n      containerPos = {top: box.top + document.documentElement.scrollTop, left: box.left};\r\n      // console.log(`getCellFromPixel scrollTop: ${document.documentElement.scrollTop}`)\r\n    } else {\r\n      containerPos = {top: this.el.offsetTop, left: this.el.offsetLeft}\r\n      // console.log(`getCellFromPixel offsetTop: ${containerPos.left} offsetLeft: ${containerPos.top}`)\r\n    }\r\n    let relativeLeft = position.left - containerPos.left;\r\n    let relativeTop = position.top - containerPos.top;\r\n\r\n    let columnWidth = (box.width / this.getColumn());\r\n    let rowHeight = (box.height / parseInt(this.el.getAttribute('gs-current-row')));\r\n\r\n    return {x: Math.floor(relativeLeft / columnWidth), y: Math.floor(relativeTop / rowHeight)};\r\n  }\r\n\r\n  /** returns the current number of rows, which will be at least `minRow` if set */\r\n  public getRow(): number {\r\n    return Math.max(this.engine.getRow(), this.opts.minRow);\r\n  }\r\n\r\n  /**\r\n   * Checks if specified area is empty.\r\n   * @param x the position x.\r\n   * @param y the position y.\r\n   * @param w the width of to check\r\n   * @param h the height of to check\r\n   */\r\n  public isAreaEmpty(x: number, y: number, w: number, h: number): boolean {\r\n    return this.engine.isAreaEmpty(x, y, w, h);\r\n  }\r\n\r\n  /**\r\n   * If you add elements to your grid by hand (or have some framework creating DOM), you have to tell gridstack afterwards to make them widgets.\r\n   * If you want gridstack to add the elements for you, use `addWidget()` instead.\r\n   * Makes the given element a widget and returns it.\r\n   * @param els widget or single selector to convert.\r\n   * @param options widget definition to use instead of reading attributes or using default sizing values\r\n   *\r\n   * @example\r\n   * let grid = GridStack.init();\r\n   * grid.el.appendChild('<div id=\"1\" gs-w=\"3\"></div>');\r\n   * grid.el.appendChild('<div id=\"2\"></div>');\r\n   * grid.makeWidget('1');\r\n   * grid.makeWidget('2', {w:2, content: 'hello'});\r\n   */\r\n  public makeWidget(els: GridStackElement, options?: GridStackWidget): GridItemHTMLElement {\r\n    let el = GridStack.getElement(els);\r\n    this._prepareElement(el, true, options);\r\n    const node = el.gridstackNode;\r\n\r\n    this._updateContainerHeight();\r\n\r\n    // see if there is a sub-grid to create\r\n    if (node.subGridOpts) {\r\n      this.makeSubGrid(el, node.subGridOpts, undefined, false); // node.subGrid will be used as option in method, no need to pass\r\n    }\r\n\r\n    // if we're adding an item into 1 column make sure\r\n    // we don't override the larger 12 column layout that was already saved. #1985\r\n    if (this.opts.column === 1) {\r\n      this._ignoreLayoutsNodeChange = true;\r\n    }\r\n    this._triggerAddEvent();\r\n    this._triggerChangeEvent();\r\n    delete this._ignoreLayoutsNodeChange;\r\n\r\n    return el;\r\n  }\r\n\r\n  /**\r\n   * Event handler that extracts our CustomEvent data out automatically for receiving custom\r\n   * notifications (see doc for supported events)\r\n   * @param name of the event (see possible values) or list of names space separated\r\n   * @param callback function called with event and optional second/third param\r\n   * (see README documentation for each signature).\r\n   *\r\n   * @example\r\n   * grid.on('added', function(e, items) { log('added ', items)} );\r\n   * or\r\n   * grid.on('added removed change', function(e, items) { log(e.type, items)} );\r\n   *\r\n   * Note: in some cases it is the same as calling native handler and parsing the event.\r\n   * grid.el.addEventListener('added', function(event) { log('added ', event.detail)} );\r\n   *\r\n   */\r\n  public on(name: 'dropped', callback: GridStackDroppedHandler): GridStack\r\n  public on(name: 'enable' | 'disable', callback: GridStackEventHandler): GridStack\r\n  public on(name: 'change' | 'added' | 'removed' | 'resizecontent', callback: GridStackNodesHandler): GridStack\r\n  public on(name: 'resizestart' | 'resize' | 'resizestop' | 'dragstart' | 'drag' | 'dragstop', callback: GridStackElementHandler): GridStack\r\n  public on(name: string, callback: GridStackEventHandlerCallback): GridStack\r\n  public on(name: GridStackEvent | string, callback: GridStackEventHandlerCallback): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      let names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.on(name, callback));\r\n      return this;\r\n    }\r\n\r\n    // native CustomEvent handlers - cash the generic handlers so we can easily remove\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      let noData = (name === 'enable' || name === 'disable');\r\n      if (noData) {\r\n        this._gsEventHandler[name] = (event: Event) => (callback as GridStackEventHandler)(event);\r\n      } else {\r\n        this._gsEventHandler[name] = (event: CustomEvent) => (callback as GridStackNodesHandler)(event, event.detail);\r\n      }\r\n      this.el.addEventListener(name, this._gsEventHandler[name]);\r\n    } else if (name === 'drag' || name === 'dragstart' || name === 'dragstop' || name === 'resizestart' || name === 'resize'\r\n      || name === 'resizestop' || name === 'dropped' || name === 'resizecontent') {\r\n      // drag&drop stop events NEED to be call them AFTER we update node attributes so handle them ourself.\r\n      // do same for start event to make it easier...\r\n      this._gsEventHandler[name] = callback;\r\n    } else {\r\n      console.error('GridStack.on(' + name + ') event not supported');\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * unsubscribe from the 'on' event GridStackEvent\r\n   * @param name of the event (see possible values) or list of names space separated\r\n   */\r\n  public off(name: GridStackEvent | string): GridStack {\r\n    // check for array of names being passed instead\r\n    if (name.indexOf(' ') !== -1) {\r\n      let names = name.split(' ') as GridStackEvent[];\r\n      names.forEach(name => this.off(name));\r\n      return this;\r\n    }\r\n\r\n    if (name === 'change' || name === 'added' || name === 'removed' || name === 'enable' || name === 'disable') {\r\n      // remove native CustomEvent handlers\r\n      if (this._gsEventHandler[name]) {\r\n        this.el.removeEventListener(name, this._gsEventHandler[name]);\r\n      }\r\n    }\r\n    delete this._gsEventHandler[name];\r\n\r\n    return this;\r\n  }\r\n\r\n  /** remove all event handlers */\r\n  public offAll(): GridStack {\r\n    Object.keys(this._gsEventHandler).forEach((key: GridStackEvent) => this.off(key));\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes widget from the grid.\r\n   * @param el  widget or selector to modify\r\n   * @param removeDOM if `false` DOM element won't be removed from the tree (Default? true).\r\n   * @param triggerEvent if `false` (quiet mode) element will not be added to removed list and no 'removed' callbacks will be called (Default? true).\r\n   */\r\n  public removeWidget(els: GridStackElement, removeDOM = true, triggerEvent = true): GridStack {\r\n    GridStack.getElements(els).forEach(el => {\r\n      if (el.parentElement && el.parentElement !== this.el) return; // not our child!\r\n      let node = el.gridstackNode;\r\n      // For Meteor support: https://github.com/gridstack/gridstack.js/pull/272\r\n      if (!node) {\r\n        node = this.engine.nodes.find(n => el === n.el);\r\n      }\r\n      if (!node) return;\r\n\r\n      if (GridStack.addRemoveCB) {\r\n        GridStack.addRemoveCB(this.el, node, false, false);\r\n      }\r\n\r\n      // remove our DOM data (circular link) and drag&drop permanently\r\n      delete el.gridstackNode;\r\n      this._removeDD(el);\r\n\r\n      this.engine.removeNode(node, removeDOM, triggerEvent);\r\n\r\n      if (removeDOM && el.parentElement) {\r\n        el.remove(); // in batch mode engine.removeNode doesn't call back to remove DOM\r\n      }\r\n    });\r\n    if (triggerEvent) {\r\n      this._triggerRemoveEvent();\r\n      this._triggerChangeEvent();\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes all widgets from the grid.\r\n   * @param removeDOM if `false` DOM elements won't be removed from the tree (Default? `true`).\r\n   */\r\n  public removeAll(removeDOM = true): GridStack {\r\n    // always remove our DOM data (circular link) before list gets emptied and drag&drop permanently\r\n    this.engine.nodes.forEach(n => {\r\n      delete n.el.gridstackNode;\r\n      this._removeDD(n.el);\r\n    });\r\n    this.engine.removeAll(removeDOM);\r\n    this._triggerRemoveEvent();\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Toggle the grid animation state.  Toggles the `grid-stack-animate` class.\r\n   * @param doAnimate if true the grid will animate.\r\n   */\r\n  public setAnimation(doAnimate: boolean): GridStack {\r\n    if (doAnimate) {\r\n      this.el.classList.add('grid-stack-animate');\r\n    } else {\r\n      this.el.classList.remove('grid-stack-animate');\r\n    }\r\n    return this;\r\n  }\r\n  /** @internal */\r\n  private hasAnimationCSS(): boolean { return this.el.classList.contains('grid-stack-animate')  }\r\n\r\n  /**\r\n   * Toggle the grid static state, which permanently removes/add Drag&Drop support, unlike disable()/enable() that just turns it off/on.\r\n   * Also toggle the grid-stack-static class.\r\n   * @param val if true the grid become static.\r\n   * @param updateClass true (default) if css class gets updated\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public setStatic(val: boolean, updateClass = true, recurse = true): GridStack {\r\n    if (!!this.opts.staticGrid === val) return this;\r\n    val ? this.opts.staticGrid = true : delete this.opts.staticGrid;\r\n    this._setupRemoveDrop();\r\n    this._setupAcceptWidget();\r\n    this.engine.nodes.forEach(n => {\r\n      this._prepareDragDropByNode(n); // either delete or init Drag&drop\r\n      if (n.subGrid && recurse) n.subGrid.setStatic(val, updateClass, recurse);\r\n    });\r\n    if (updateClass) { this._setStaticClass(); }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Updates widget position/size and other info. Note: if you need to call this on all nodes, use load() instead which will update what changed.\r\n   * @param els  widget or selector of objects to modify (note: setting the same x,y for multiple items will be indeterministic and likely unwanted)\r\n   * @param opt new widget options (x,y,w,h, etc..). Only those set will be updated.\r\n   */\r\n  public update(els: GridStackElement, opt: GridStackWidget): GridStack {\r\n\r\n    // support legacy call for now ?\r\n    if (arguments.length > 2) {\r\n      console.warn('gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update(el, {x, w, content, ...})`. It will be removed soon');\r\n      // eslint-disable-next-line prefer-rest-params\r\n      let a = arguments, i = 1;\r\n      opt = { x:a[i++], y:a[i++], w:a[i++], h:a[i++] };\r\n      return this.update(els, opt);\r\n    }\r\n\r\n    GridStack.getElements(els).forEach(el => {\r\n      let n = el?.gridstackNode;\r\n      if (!n) return;\r\n      let w = Utils.cloneDeep(opt); // make a copy we can modify in case they re-use it or multiple items\r\n      this.engine.nodeBoundFix(w);\r\n      delete w.autoPosition;\r\n      delete w.id;\r\n\r\n      // move/resize widget if anything changed\r\n      let keys = ['x', 'y', 'w', 'h'];\r\n      let m: GridStackWidget;\r\n      if (keys.some(k => w[k] !== undefined && w[k] !== n[k])) {\r\n        m = {};\r\n        keys.forEach(k => {\r\n          m[k] = (w[k] !== undefined) ? w[k] : n[k];\r\n          delete w[k];\r\n        });\r\n      }\r\n      // for a move as well IFF there is any min/max fields set\r\n      if (!m && (w.minW || w.minH || w.maxW || w.maxH)) {\r\n        m = {}; // will use node position but validate values\r\n      }\r\n\r\n      // check for content changing\r\n      if (w.content !== undefined) {\r\n        const itemContent = el.querySelector('.grid-stack-item-content');\r\n        if (itemContent && itemContent.innerHTML !== w.content) {\r\n          itemContent.innerHTML = w.content;\r\n          // restore any sub-grid back\r\n          if (n.subGrid?.el) {\r\n            itemContent.appendChild(n.subGrid.el);\r\n            if (!n.subGrid.opts.styleInHead) n.subGrid._updateStyles(true); // force create\r\n          }\r\n        }\r\n        delete w.content;\r\n      }\r\n\r\n      // any remaining fields are assigned, but check for dragging changes, resize constrain\r\n      let changed = false;\r\n      let ddChanged = false;\r\n      for (const key in w) {\r\n        if (key[0] !== '_' && n[key] !== w[key]) {\r\n          n[key] = w[key];\r\n          changed = true;\r\n          ddChanged = ddChanged || (!this.opts.staticGrid && (key === 'noResize' || key === 'noMove' || key === 'locked'));\r\n        }\r\n      }\r\n      Utils.sanitizeMinMax(n);\r\n\r\n      // finally move the widget and update attr\r\n      if (m) {\r\n        const widthChanged = (m.w !== undefined && m.w !== n.w);\r\n        this.moveNode(n, m);\r\n        this.resizeToContentCheck(widthChanged, n); // wait for animation if we changed width\r\n      }\r\n      if (m || changed) {\r\n        this._writeAttr(el, n);\r\n      }\r\n      if (ddChanged) {\r\n        this._prepareDragDropByNode(n);\r\n      }\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  private moveNode(n: GridStackNode, m: GridStackMoveOpts) {\r\n    this.engine.cleanNodes()\r\n      .beginUpdate(n)\r\n      .moveNode(n, m);\r\n    this._updateContainerHeight();\r\n    this._triggerChangeEvent();\r\n    this.engine.endUpdate();\r\n  }\r\n\r\n  /**\r\n   * Updates widget height to match the content height to avoid v-scrollbar or dead space.\r\n   * Note: this assumes only 1 child under resizeToContentParent='.grid-stack-item-content' (sized to gridItem minus padding) that is at the entire content size wanted.\r\n   * @param el grid item element\r\n   * @param useNodeH set to true if GridStackNode.h should be used instead of actual container height when we don't need to wait for animation to finish to get actual DOM heights\r\n   */\r\n  public resizeToContent(el: GridItemHTMLElement) {\r\n    if (!el) return;\r\n    el.classList.remove('size-to-content-max');\r\n    if (!el.clientHeight) return; // 0 when hidden, skip\r\n    const n = el.gridstackNode;\r\n    if (!n) return;\r\n    const grid = n.grid;\r\n    if (!grid || el.parentElement !== grid.el) return; // skip if we are not inside a grid\r\n    const cell = grid.getCellHeight(true);\r\n    if (!cell) return;\r\n    let height = n.h ? n.h * cell : el.clientHeight; // getBoundingClientRect().height seem to flicker back and forth\r\n    let item: Element;\r\n    if (n.resizeToContentParent) item = el.querySelector(n.resizeToContentParent);\r\n    if (!item) item = el.querySelector(GridStack.resizeToContentParent);\r\n    if (!item) return;\r\n    const padding = el.clientHeight - item.clientHeight; // full - available height to our child (minus border, padding...)\r\n    const itemH = n.h ? n.h * cell - padding : item.clientHeight; // calculated to what cellHeight is or will become (rather than actual to prevent waiting for animation to finish)\r\n    let wantedH: number;\r\n    if (n.subGrid) {\r\n      // sub-grid - use their actual row count * their cell height\r\n      wantedH = n.subGrid.getRow() * n.subGrid.getCellHeight(true);\r\n    } else {\r\n      // NOTE: clientHeight & getBoundingClientRect() is undefined for text and other leaf nodes. use <div> container!\r\n      const child = item.firstElementChild;\r\n      if (!child) { console.error(`Error: GridStack.resizeToContent() widget id:${n.id} '${GridStack.resizeToContentParent}'.firstElementChild is null, make sure to have a div like container. Skipping sizing.`); return; }\r\n      wantedH = child.getBoundingClientRect().height || itemH;\r\n    }\r\n    if (itemH === wantedH) return;\r\n    height += wantedH - itemH;\r\n    let h = Math.ceil(height / cell);\r\n    // check for min/max and special sizing\r\n    const softMax = Number.isInteger(n.sizeToContent) ? n.sizeToContent as number : 0;\r\n    if (softMax && h > softMax) {\r\n      h = softMax;\r\n      el.classList.add('size-to-content-max');  // get v-scroll back\r\n    }\r\n    if (n.minH && h < n.minH) h = n.minH;\r\n    else if (n.maxH && h > n.maxH) h = n.maxH;\r\n    if (h !== n.h) {\r\n      grid._ignoreLayoutsNodeChange = true;\r\n      grid.moveNode(n, {h});\r\n      delete grid._ignoreLayoutsNodeChange;\r\n    }\r\n  }\r\n\r\n  /** call the user resize (so they can do extra work) else our build in version */\r\n  private resizeToContentCBCheck(el: GridItemHTMLElement) {\r\n    if (GridStack.resizeToContentCB) GridStack.resizeToContentCB(el);\r\n    else this.resizeToContent(el);\r\n  }\r\n\r\n  /**\r\n   * Updates the margins which will set all 4 sides at once - see `GridStackOptions.margin` for format options (CSS string format of 1,2,4 values or single number).\r\n   * @param value margin value\r\n   */\r\n  public margin(value: numberOrString): GridStack {\r\n    let isMultiValue = (typeof value === 'string' && value.split(' ').length > 1);\r\n    // check if we can skip re-creating our CSS file... won't check if multi values (too much hassle)\r\n    if (!isMultiValue) {\r\n      let data = Utils.parseHeight(value);\r\n      if (this.opts.marginUnit === data.unit && this.opts.margin === data.h) return;\r\n    }\r\n    // re-use existing margin handling\r\n    this.opts.margin = value;\r\n    this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = undefined;\r\n    this._initMargin();\r\n\r\n    this._updateStyles(true); // true = force re-create\r\n\r\n    return this;\r\n  }\r\n\r\n  /** returns current margin number value (undefined if 4 sides don't match) */\r\n  public getMargin(): number { return this.opts.margin as number; }\r\n\r\n  /**\r\n   * Returns true if the height of the grid will be less than the vertical\r\n   * constraint. Always returns true if grid doesn't have height constraint.\r\n   * @param node contains x,y,w,h,auto-position options\r\n   *\r\n   * @example\r\n   * if (grid.willItFit(newWidget)) {\r\n   *   grid.addWidget(newWidget);\r\n   * } else {\r\n   *   alert('Not enough free space to place the widget');\r\n   * }\r\n   */\r\n  public willItFit(node: GridStackWidget): boolean {\r\n    // support legacy call for now\r\n    if (arguments.length > 1) {\r\n      console.warn('gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon');\r\n      // eslint-disable-next-line prefer-rest-params\r\n      let a = arguments, i = 0,\r\n        w: GridStackWidget = { x:a[i++], y:a[i++], w:a[i++], h:a[i++], autoPosition:a[i++] };\r\n      return this.willItFit(w);\r\n    }\r\n    return this.engine.willItFit(node);\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerChangeEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    let elements = this.engine.getDirtyNodes(true); // verify they really changed\r\n    if (elements && elements.length) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(elements);\r\n      }\r\n      this._triggerEvent('change', elements);\r\n    }\r\n    this.engine.saveInitial(); // we called, now reset initial values & dirty flags\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerAddEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.addedNodes?.length) {\r\n      if (!this._ignoreLayoutsNodeChange) {\r\n        this.engine.layoutsNodesChange(this.engine.addedNodes);\r\n      }\r\n      // prevent added nodes from also triggering 'change' event (which is called next)\r\n      this.engine.addedNodes.forEach(n => { delete n._dirty; });\r\n      this._triggerEvent('added', this.engine.addedNodes);\r\n      this.engine.addedNodes = [];\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  public _triggerRemoveEvent(): GridStack {\r\n    if (this.engine.batchMode) return this;\r\n    if (this.engine.removedNodes?.length) {\r\n      this._triggerEvent('removed', this.engine.removedNodes);\r\n      this.engine.removedNodes = [];\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _triggerEvent(type: string, data?: GridStackNode[]): GridStack {\r\n    let event = data ? new CustomEvent(type, {bubbles: false, detail: data}) : new Event(type);\r\n    this.el.dispatchEvent(event);\r\n    return this;\r\n  }\r\n\r\n  /** @internal called to delete the current dynamic style sheet used for our layout */\r\n  protected _removeStylesheet(): GridStack {\r\n\r\n    if (this._styles) {\r\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode as HTMLElement;\r\n      Utils.removeStylesheet(this._styleSheetClass, styleLocation);\r\n      delete this._styles;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal updated/create the CSS styles for row based layout and initial margin setting */\r\n  protected _updateStyles(forceUpdate = false, maxH?: number): GridStack {\r\n    // call to delete existing one if we change cellHeight / margin\r\n    if (forceUpdate) {\r\n      this._removeStylesheet();\r\n    }\r\n\r\n    if (maxH === undefined) maxH = this.getRow();\r\n    this._updateContainerHeight();\r\n\r\n    // if user is telling us they will handle the CSS themselves by setting heights to 0. Do we need this opts really ??\r\n    if (this.opts.cellHeight === 0) {\r\n      return this;\r\n    }\r\n\r\n    let cellHeight = this.opts.cellHeight as number;\r\n    let cellHeightUnit = this.opts.cellHeightUnit;\r\n    let prefix = `.${this._styleSheetClass} > .${this.opts.itemClass}`;\r\n\r\n    // create one as needed\r\n    if (!this._styles) {\r\n      // insert style to parent (instead of 'head' by default) to support WebComponent\r\n      const styleLocation = this.opts.styleInHead ? undefined : this.el.parentNode as HTMLElement;\r\n      this._styles = Utils.createStylesheet(this._styleSheetClass, styleLocation, {\r\n        nonce: this.opts.nonce,\r\n      });\r\n      if (!this._styles) return this;\r\n      this._styles._max = 0;\r\n\r\n      // these are done once only\r\n      Utils.addCSSRule(this._styles, prefix, `height: ${cellHeight}${cellHeightUnit}`);\r\n      // content margins\r\n      let top: string = this.opts.marginTop + this.opts.marginUnit;\r\n      let bottom: string = this.opts.marginBottom + this.opts.marginUnit;\r\n      let right: string = this.opts.marginRight + this.opts.marginUnit;\r\n      let left: string = this.opts.marginLeft + this.opts.marginUnit;\r\n      let content = `${prefix} > .grid-stack-item-content`;\r\n      let placeholder = `.${this._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`;\r\n      Utils.addCSSRule(this._styles, content, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\r\n      Utils.addCSSRule(this._styles, placeholder, `top: ${top}; right: ${right}; bottom: ${bottom}; left: ${left};`);\r\n      // resize handles offset (to match margin)\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-n`, `top: ${top};`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-s`, `bottom: ${bottom}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-ne`, `right: ${right}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-e`, `right: ${right}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-se`, `right: ${right}; bottom: ${bottom}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-nw`, `left: ${left}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-w`, `left: ${left}`);\r\n      Utils.addCSSRule(this._styles, `${prefix} > .ui-resizable-sw`, `left: ${left}; bottom: ${bottom}`);\r\n    }\r\n\r\n    // now update the height specific fields\r\n    maxH = maxH || this._styles._max;\r\n    if (maxH > this._styles._max) {\r\n      let getHeight = (rows: number): string => (cellHeight * rows) + cellHeightUnit;\r\n      for (let i = this._styles._max + 1; i <= maxH; i++) { // start at 1\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-y=\"${i}\"]`, `top: ${getHeight(i)}`);\r\n        Utils.addCSSRule(this._styles, `${prefix}[gs-h=\"${i+1}\"]`, `height: ${getHeight(i+1)}`); // start at 2\r\n      }\r\n      this._styles._max = maxH;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _updateContainerHeight(): GridStack {\r\n    if (!this.engine || this.engine.batchMode) return this;\r\n    const parent = this.parentGridItem;\r\n    let row = this.getRow() + this._extraDragRow; // this checks for minRow already\r\n    const cellHeight = this.opts.cellHeight as number;\r\n    const unit = this.opts.cellHeightUnit;\r\n    if (!cellHeight) return this;\r\n\r\n    // check for css min height (non nested grid). TODO: support mismatch, say: min % while unit is px.\r\n    if (!parent) {\r\n      const cssMinHeight = Utils.parseHeight(getComputedStyle(this.el)['minHeight']);\r\n      if (cssMinHeight.h > 0 && cssMinHeight.unit === unit) {\r\n        const minRow = Math.floor(cssMinHeight.h / cellHeight);\r\n        if (row < minRow) {\r\n          row = minRow;\r\n        }\r\n      }\r\n    }\r\n\r\n    this.el.setAttribute('gs-current-row', String(row));\r\n    this.el.style.removeProperty('min-height');\r\n    this.el.style.removeProperty('height');\r\n    if (row) {\r\n      // nested grids have 'insert:0' to fill the space of parent by default, but we may be taller so use min-height for possible scrollbars\r\n      this.el.style[parent ? 'minHeight' : 'height'] = row * cellHeight + unit;\r\n    }\r\n\r\n    // if we're a nested grid inside an sizeToContent item, tell it to resize itself too\r\n    if (parent && !parent.grid.engine.batchMode && Utils.shouldSizeToContent(parent)) {\r\n      parent.grid.resizeToContentCBCheck(parent.el);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _prepareElement(el: GridItemHTMLElement, triggerAddEvent = false, node?: GridStackNode): GridStack {\r\n    node = node || this._readAttr(el);\r\n    el.gridstackNode = node;\r\n    node.el = el;\r\n    node.grid = this;\r\n    node = this.engine.addNode(node, triggerAddEvent);\r\n\r\n    // write the dom sizes and class\r\n    this._writeAttr(el, node);\r\n    el.classList.add(gridDefaults.itemClass, this.opts.itemClass);\r\n    const sizeToContent = Utils.shouldSizeToContent(node);\r\n    sizeToContent ? el.classList.add('size-to-content') : el.classList.remove('size-to-content');\r\n    if (sizeToContent) this.resizeToContentCheck(false, node);\r\n\r\n    this._prepareDragDropByNode(node);\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to write position x,y,w,h attributes back to element */\r\n  protected _writePosAttr(el: HTMLElement, n: GridStackPosition): GridStack {\r\n    if (n.x !== undefined && n.x !== null) { el.setAttribute('gs-x', String(n.x)); }\r\n    if (n.y !== undefined && n.y !== null) { el.setAttribute('gs-y', String(n.y)); }\r\n    n.w > 1 ? el.setAttribute('gs-w', String(n.w)) : el.removeAttribute('gs-w');\r\n    n.h > 1 ? el.setAttribute('gs-h', String(n.h)) : el.removeAttribute('gs-h');\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to write any default attributes back to element */\r\n  protected _writeAttr(el: HTMLElement, node: GridStackWidget): GridStack {\r\n    if (!node) return this;\r\n    this._writePosAttr(el, node);\r\n\r\n    let attrs /*: GridStackWidget but strings */ = { // remaining attributes\r\n      autoPosition: 'gs-auto-position',\r\n      noResize: 'gs-no-resize',\r\n      noMove: 'gs-no-move',\r\n      locked: 'gs-locked',\r\n      id: 'gs-id',\r\n    };\r\n    for (const key in attrs) {\r\n      if (node[key]) { // 0 is valid for x,y only but done above already and not in list anyway\r\n        el.setAttribute(attrs[key], String(node[key]));\r\n      } else {\r\n        el.removeAttribute(attrs[key]);\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal call to read any default attributes from element */\r\n  protected _readAttr(el: HTMLElement, clearDefaultAttr = true): GridStackWidget {\r\n    let n: GridStackNode = {};\r\n    n.x = Utils.toNumber(el.getAttribute('gs-x'));\r\n    n.y = Utils.toNumber(el.getAttribute('gs-y'));\r\n    n.w = Utils.toNumber(el.getAttribute('gs-w'));\r\n    n.h = Utils.toNumber(el.getAttribute('gs-h'));\r\n    n.autoPosition = Utils.toBool(el.getAttribute('gs-auto-position'));\r\n    n.noResize = Utils.toBool(el.getAttribute('gs-no-resize'));\r\n    n.noMove = Utils.toBool(el.getAttribute('gs-no-move'));\r\n    n.locked = Utils.toBool(el.getAttribute('gs-locked'));\r\n    n.id = el.getAttribute('gs-id');\r\n\r\n    // read but never written out\r\n    n.maxW = Utils.toNumber(el.getAttribute('gs-max-w'));\r\n    n.minW = Utils.toNumber(el.getAttribute('gs-min-w'));\r\n    n.maxH = Utils.toNumber(el.getAttribute('gs-max-h'));\r\n    n.minH = Utils.toNumber(el.getAttribute('gs-min-h'));\r\n\r\n    // v8.x optimization to reduce un-needed attr that don't render or are default CSS\r\n    if (clearDefaultAttr) {\r\n      if (n.w === 1) el.removeAttribute('gs-w');\r\n      if (n.h === 1) el.removeAttribute('gs-h');\r\n      if (n.maxW) el.removeAttribute('gs-max-w');\r\n      if (n.minW) el.removeAttribute('gs-min-w');\r\n      if (n.maxH) el.removeAttribute('gs-max-h');\r\n      if (n.minH) el.removeAttribute('gs-min-h');\r\n    }\r\n\r\n    // remove any key not found (null or false which is default)\r\n    for (const key in n) {\r\n      if (!n.hasOwnProperty(key)) return;\r\n      if (!n[key] && n[key] !== 0) { // 0 can be valid value (x,y only really)\r\n        delete n[key];\r\n      }\r\n    }\r\n\r\n    return n;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _setStaticClass(): GridStack {\r\n    let classes = ['grid-stack-static'];\r\n\r\n    if (this.opts.staticGrid) {\r\n      this.el.classList.add(...classes);\r\n      this.el.setAttribute('gs-static', 'true');\r\n    } else {\r\n      this.el.classList.remove(...classes);\r\n      this.el.removeAttribute('gs-static');\r\n\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * called when we are being resized - check if the one Column Mode needs to be turned on/off\r\n   * and remember the prev columns we used, or get our count from parent, as well as check for cellHeight==='auto' (square)\r\n   * or `sizeToContent` gridItem options.\r\n   */\r\n  public onResize(): GridStack {\r\n    if (!this.el?.clientWidth) return; // return if we're gone or no size yet (will get called again)\r\n    if (this.prevWidth === this.el.clientWidth) return; // no-op\r\n    this.prevWidth = this.el.clientWidth\r\n    // console.log('onResize ', this.el.clientWidth);\r\n\r\n    this.batchUpdate();\r\n\r\n    // see if we're nested and take our column count from our parent....\r\n    let columnChanged = false;\r\n    if (this._autoColumn && this.parentGridItem) {\r\n      if (this.opts.column !== this.parentGridItem.w) {\r\n        this.column(this.parentGridItem.w, 'none');\r\n        columnChanged = true;\r\n      }\r\n    } else {\r\n      // else check for dynamic column\r\n      columnChanged = this.checkDynamicColumn();\r\n    }\r\n\r\n    // make the cells content square again\r\n    if (this._isAutoCellHeight) this.cellHeight();\r\n\r\n    // update any nested grids, or items size\r\n    this.engine.nodes.forEach(n => {\r\n      if (n.subGrid) n.subGrid.onResize()\r\n    });\r\n\r\n    if (!this._skipInitialResize) this.resizeToContentCheck(columnChanged); // wait for anim of column changed (DOM reflow before we can size correctly)\r\n    delete this._skipInitialResize;\r\n\r\n    this.batchUpdate(false);\r\n\r\n    return this;\r\n  }\r\n\r\n  /** resizes content for given node (or all) if shouldSizeToContent() is true */\r\n  private resizeToContentCheck(delay = false, n: GridStackNode = undefined) {\r\n    if (!this.engine) return; // we've been deleted in between!\r\n\r\n    // update any gridItem height with sizeToContent, but wait for DOM $animation_speed to settle if we changed column count\r\n    // TODO: is there a way to know what the final (post animation) size of the content will be so we can animate the column width and height together rather than sequentially ?\r\n    if (delay && this.hasAnimationCSS()) return setTimeout(() => this.resizeToContentCheck(false, n), 300 + 10);\r\n\r\n    if (n) {\r\n      if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\r\n    } else if (this.engine.nodes.some(n => Utils.shouldSizeToContent(n))) {\r\n      const nodes = [...this.engine.nodes]; // in case order changes while resizing one\r\n      this.batchUpdate();\r\n      nodes.forEach(n => {\r\n        if (Utils.shouldSizeToContent(n)) this.resizeToContentCBCheck(n.el);\r\n      });\r\n      this.batchUpdate(false);\r\n    }\r\n    // call this regardless of shouldSizeToContent because widget might need to stretch to take available space after a resize\r\n    if (this._gsEventHandler['resizecontent']) this._gsEventHandler['resizecontent'](null, n ? [n] : this.engine.nodes);\r\n  }\r\n\r\n  /** add or remove the grid element size event handler */\r\n  protected _updateResizeEvent(forceRemove = false): GridStack {\r\n    // only add event if we're not nested (parent will call us) and we're auto sizing cells or supporting dynamic column (i.e. doing work)\r\n    // or supporting new sizeToContent option.\r\n    const trackSize = !this.parentGridItem && (this._isAutoCellHeight || this.opts.sizeToContent || this.opts.columnOpts\r\n      || this.engine.nodes.find(n => n.sizeToContent));\r\n\r\n    if (!forceRemove && trackSize && !this.resizeObserver) {\r\n      this._sizeThrottle = Utils.throttle(() => this.onResize(), this.opts.cellHeightThrottle);\r\n      this.resizeObserver = new ResizeObserver(() => this._sizeThrottle());\r\n      this.resizeObserver.observe(this.el);\r\n      this._skipInitialResize = true; // makeWidget will originally have called on startup\r\n    } else if ((forceRemove || !trackSize) && this.resizeObserver) {\r\n      this.resizeObserver.disconnect();\r\n      delete this.resizeObserver;\r\n      delete this._sizeThrottle;\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal convert a potential selector into actual element */\r\n  public static getElement(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement { return Utils.getElement(els) }\r\n  /** @internal */\r\n  public static getElements(els: GridStackElement = '.grid-stack-item'): GridItemHTMLElement[] { return Utils.getElements(els) }\r\n  /** @internal */\r\n  public static getGridElement(els: GridStackElement): GridHTMLElement { return GridStack.getElement(els) }\r\n  /** @internal */\r\n  public static getGridElements(els: string): GridHTMLElement[] { return Utils.getElements(els) }\r\n\r\n  /** @internal initialize margin top/bottom/left/right and units */\r\n  protected _initMargin(): GridStack {\r\n\r\n    let data: HeightData;\r\n    let margin = 0;\r\n\r\n    // support passing multiple values like CSS (ex: '5px 10px 0 20px')\r\n    let margins: string[] = [];\r\n    if (typeof this.opts.margin === 'string') {\r\n      margins = this.opts.margin.split(' ')\r\n    }\r\n    if (margins.length === 2) { // top/bot, left/right like CSS\r\n      this.opts.marginTop = this.opts.marginBottom = margins[0];\r\n      this.opts.marginLeft = this.opts.marginRight = margins[1];\r\n    } else if (margins.length === 4) { // Clockwise like CSS\r\n      this.opts.marginTop = margins[0];\r\n      this.opts.marginRight = margins[1];\r\n      this.opts.marginBottom = margins[2];\r\n      this.opts.marginLeft = margins[3];\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.margin);\r\n      this.opts.marginUnit = data.unit;\r\n      margin = this.opts.margin = data.h;\r\n    }\r\n\r\n    // see if top/bottom/left/right need to be set as well\r\n    if (this.opts.marginTop === undefined) {\r\n      this.opts.marginTop = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginTop);\r\n      this.opts.marginTop = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginBottom === undefined) {\r\n      this.opts.marginBottom = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginBottom);\r\n      this.opts.marginBottom = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginRight === undefined) {\r\n      this.opts.marginRight = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginRight);\r\n      this.opts.marginRight = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n\r\n    if (this.opts.marginLeft === undefined) {\r\n      this.opts.marginLeft = margin;\r\n    } else {\r\n      data = Utils.parseHeight(this.opts.marginLeft);\r\n      this.opts.marginLeft = data.h;\r\n      delete this.opts.margin;\r\n    }\r\n    this.opts.marginUnit = data.unit; // in case side were spelled out, use those units instead...\r\n    if (this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight) {\r\n      this.opts.margin = this.opts.marginTop; // makes it easier to check for no-ops in setMargin()\r\n    }\r\n    return this;\r\n  }\r\n\r\n  static GDRev = '10.1.1';\r\n\r\n  /* ===========================================================================================\r\n   * drag&drop methods that used to be stubbed out and implemented in dd-gridstack.ts\r\n   * but caused loading issues in prod - see https://github.com/gridstack/gridstack.js/issues/2039\r\n   * ===========================================================================================\r\n   */\r\n\r\n  /** get the global (but static to this code) DD implementation */\r\n  public static getDD(): DDGridStack {\r\n    return dd;\r\n  }\r\n\r\n  /**\r\n   * call to setup dragging in from the outside (say toolbar), by specifying the class selection and options.\r\n   * Called during GridStack.init() as options, but can also be called directly (last param are used) in case the toolbar\r\n   * is dynamically create and needs to be set later.\r\n   * @param dragIn string selector (ex: '.sidebar .grid-stack-item') or list of dom elements\r\n   * @param dragInOptions options - see DDDragInOpt. (default: {handle: '.grid-stack-item-content', appendTo: 'body'}\r\n   * @param root optional root which defaults to document (for shadow dom pas the parent HTMLDocument)\r\n   */\r\n  public static setupDragIn(dragIn?: string | HTMLElement[], dragInOptions?: DDDragInOpt, root: HTMLElement | Document = document): void {\r\n    if (dragInOptions?.pause !== undefined) {\r\n      DDManager.pauseDrag = dragInOptions.pause;\r\n    }\r\n\r\n    dragInOptions = {...dragInDefaultOptions, ...(dragInOptions || {})};\r\n    let els: HTMLElement[] = (typeof dragIn === 'string') ? Utils.getElements(dragIn, root) : dragIn;\r\n    if (els.length) els?.forEach(el => {\r\n      if (!dd.isDraggable(el)) dd.dragIn(el, dragInOptions);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables dragging by the user of specific grid element. If you want all items, and have it affect future items, use enableMove() instead. No-op for static grids.\r\n   * IF you are looking to prevent an item from moving (due to being pushed around by another during collision) use locked property instead.\r\n   * @param els widget or selector to modify.\r\n   * @param val if true widget will be draggable, assuming the parent grid isn't noMove or static.\r\n   */\r\n  public movable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      const n = el.gridstackNode;\r\n      if (!n) return;\r\n      val ? delete n.noMove : n.noMove = true;\r\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/Disables user resizing of specific grid element. If you want all items, and have it affect future items, use enableResize() instead. No-op for static grids.\r\n   * @param els  widget or selector to modify\r\n   * @param val  if true widget will be resizable, assuming the parent grid isn't noResize or static.\r\n   */\r\n  public resizable(els: GridStackElement, val: boolean): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't resize a static grid!\r\n    GridStack.getElements(els).forEach(el => {\r\n      let n = el.gridstackNode;\r\n      if (!n) return;\r\n      val ? delete n.noResize : n.noResize = true;\r\n      this._prepareDragDropByNode(n); // init DD if need be, and adjust\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Temporarily disables widgets moving/resizing.\r\n   * If you want a more permanent way (which freezes up resources) use `setStatic(true)` instead.\r\n   * Note: no-op for static grid\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(false);\r\n   *  grid.enableResize(false);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public disable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(false, recurse);\r\n    this.enableResize(false, recurse);\r\n    this._triggerEvent('disable');\r\n    return this;\r\n  }\r\n  /**\r\n   * Re-enables widgets moving/resizing - see disable().\r\n   * Note: no-op for static grid.\r\n   * This is a shortcut for:\r\n   * @example\r\n   *  grid.enableMove(true);\r\n   *  grid.enableResize(true);\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enable(recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return;\r\n    this.enableMove(true, recurse);\r\n    this.enableResize(true, recurse);\r\n    this._triggerEvent('enable');\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget moving. No-op for static grids, and locally defined items still overrule\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enableMove(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't move a static grid!\r\n    doEnable ? delete this.opts.disableDrag : this.opts.disableDrag = true; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this._prepareDragDropByNode(n);\r\n      if (n.subGrid && recurse) n.subGrid.enableMove(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Enables/disables widget resizing. No-op for static grids.\r\n   * @param recurse true (default) if sub-grids also get updated\r\n   */\r\n  public enableResize(doEnable: boolean, recurse = true): GridStack {\r\n    if (this.opts.staticGrid) return this; // can't size a static grid!\r\n    doEnable ? delete this.opts.disableResize : this.opts.disableResize = true; // FIRST before we update children as grid overrides #1658\r\n    this.engine.nodes.forEach(n => {\r\n      this._prepareDragDropByNode(n);\r\n      if (n.subGrid && recurse) n.subGrid.enableResize(doEnable, recurse);\r\n    });\r\n    return this;\r\n  }\r\n\r\n  /** @internal removes any drag&drop present (called during destroy) */\r\n  protected _removeDD(el: DDElementHost): GridStack {\r\n    dd.draggable(el, 'destroy').resizable(el, 'destroy');\r\n    if (el.gridstackNode) {\r\n      delete el.gridstackNode._initDD; // reset our DD init flag\r\n    }\r\n    delete el.ddElement;\r\n    return this;\r\n  }\r\n\r\n  /** @internal called to add drag over to support widgets being added externally */\r\n  protected _setupAcceptWidget(): GridStack {\r\n\r\n    // check if we need to disable things\r\n    if (this.opts.staticGrid || (!this.opts.acceptWidgets && !this.opts.removable)) {\r\n      dd.droppable(this.el, 'destroy');\r\n      return this;\r\n    }\r\n\r\n    // vars shared across all methods\r\n    let cellHeight: number, cellWidth: number;\r\n\r\n    let onDrag = (event: DragEvent, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      let node = el.gridstackNode;\r\n      if (!node) return;\r\n\r\n      helper = helper || el;\r\n\r\n      // if the element is being dragged from outside, scale it down to match the grid's scale\r\n      // and slightly adjust its position relative to the mouse\r\n      if (!node.grid?.el) {\r\n        // this scales the helper down\r\n        helper.style.transform = `scale(${1 / this.dragTransform.xScale},${1 / this.dragTransform.yScale})`;\r\n        // this makes it so that the helper is well positioned relative to the mouse after scaling\r\n        const helperRect = helper.getBoundingClientRect();\r\n        helper.style.left = helperRect.x + (this.dragTransform.xScale - 1) * (event.clientX - helperRect.x) / this.dragTransform.xScale + 'px';\r\n        helper.style.top = helperRect.y + (this.dragTransform.yScale - 1) * (event.clientY - helperRect.y) / this.dragTransform.yScale + 'px';\r\n        helper.style.transformOrigin = `0px 0px`\r\n      }\r\n\r\n      let parent = this.el.getBoundingClientRect();\r\n      let {top, left} = helper.getBoundingClientRect();\r\n      left -= parent.left;\r\n      top -= parent.top;\r\n      let ui: DDUIData = {\r\n        position: {\r\n          top: top * this.dragTransform.xScale,\r\n          left: left * this.dragTransform.yScale\r\n        }\r\n      };\r\n\r\n      if (node._temporaryRemoved) {\r\n        node.x = Math.max(0, Math.round(left / cellWidth));\r\n        node.y = Math.max(0, Math.round(top / cellHeight));\r\n        delete node.autoPosition;\r\n        this.engine.nodeBoundFix(node);\r\n\r\n        // don't accept *initial* location if doesn't fit #1419 (locked drop region, or can't grow), but maybe try if it will go somewhere\r\n        if (!this.engine.willItFit(node)) {\r\n          node.autoPosition = true; // ignore x,y and try for any slot...\r\n          if (!this.engine.willItFit(node)) {\r\n            dd.off(el, 'drag'); // stop calling us\r\n            return; // full grid or can't grow\r\n          }\r\n          if (node._willFitPos) {\r\n            // use the auto position instead #1687\r\n            Utils.copyPos(node, node._willFitPos);\r\n            delete node._willFitPos;\r\n          }\r\n        }\r\n\r\n        // re-use the existing node dragging method\r\n        this._onStartMoving(helper, event, ui, node, cellWidth, cellHeight);\r\n      } else {\r\n        // re-use the existing node dragging that does so much of the collision detection\r\n        this._dragOrResize(helper, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n    }\r\n\r\n    dd.droppable(this.el, {\r\n      accept: (el: GridItemHTMLElement) => {\r\n        let node: GridStackNode = el.gridstackNode;\r\n        // set accept drop to true on ourself (which we ignore) so we don't get \"can't drop\" icon in HTML5 mode while moving\r\n        if (node?.grid === this) return true;\r\n        if (!this.opts.acceptWidgets) return false;\r\n        // check for accept method or class matching\r\n        let canAccept = true;\r\n        if (typeof this.opts.acceptWidgets === 'function') {\r\n          canAccept = this.opts.acceptWidgets(el);\r\n        } else {\r\n          let selector = (this.opts.acceptWidgets === true ? '.grid-stack-item' : this.opts.acceptWidgets as string);\r\n          canAccept = el.matches(selector);\r\n        }\r\n        // finally check to make sure we actually have space left #1571\r\n        if (canAccept && node && this.opts.maxRow) {\r\n          let n = {w: node.w, h: node.h, minW: node.minW, minH: node.minH}; // only width/height matters and autoPosition\r\n          canAccept = this.engine.willItFit(n);\r\n        }\r\n        return canAccept;\r\n      }\r\n    })\r\n    /**\r\n     * entering our grid area\r\n     */\r\n      .on(this.el, 'dropover', (event: Event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      // console.log(`over ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        let node = el.gridstackNode;\r\n        // ignore drop enter on ourself (unless we temporarily removed) which happens on a simple drag of our item\r\n        if (node?.grid === this && !node._temporaryRemoved) {\r\n        // delete node._added; // reset this to track placeholder again in case we were over other grid #1484 (dropout doesn't always clear)\r\n          return false; // prevent parent from receiving msg (which may be a grid as well)\r\n        }\r\n\r\n        // fix #1578 when dragging fast, we may not get a leave on the previous grid so force one now\r\n        if (node?.grid && node.grid !== this && !node._temporaryRemoved) {\r\n        // console.log('dropover without leave'); // TEST\r\n          let otherGrid = node.grid;\r\n          otherGrid._leave(el, helper);\r\n        }\r\n\r\n        // cache cell dimensions (which don't change), position can animate if we removed an item in otherGrid that affects us...\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true);\r\n\r\n        // load any element attributes if we don't have a node\r\n        if (!node) {\r\n          node = this._readAttr(el, false); // don't wipe external (e.g. drag toolbar) attr #2354\r\n        }\r\n        if (!node.grid) {\r\n          node._isExternal = true;\r\n          el.gridstackNode = node;\r\n        }\r\n\r\n        // calculate the grid size based on element outer size\r\n        helper = helper || el;\r\n        let w = node.w || Math.round(helper.offsetWidth / cellWidth) || 1;\r\n        let h = node.h || Math.round(helper.offsetHeight / cellHeight) || 1;\r\n\r\n        // if the item came from another grid, make a copy and save the original info in case we go back there\r\n        if (node.grid && node.grid !== this) {\r\n        // copy the node original values (min/max/id/etc...) but override width/height/other flags which are this grid specific\r\n        // console.log('dropover cloning node'); // TEST\r\n          if (!el._gridstackNodeOrig) el._gridstackNodeOrig = node; // shouldn't have multiple nested!\r\n          el.gridstackNode = node = {...node, w, h, grid: this};\r\n          delete node.x;\r\n          delete node.y;\r\n          this.engine.cleanupNode(node)\r\n            .nodeBoundFix(node);\r\n          // restore some internal fields we need after clearing them all\r\n          node._initDD =\r\n          node._isExternal =  // DOM needs to be re-parented on a drop\r\n          node._temporaryRemoved = true; // so it can be inserted onDrag below\r\n        } else {\r\n          node.w = w; node.h = h;\r\n          node._temporaryRemoved = true; // so we can insert it\r\n        }\r\n\r\n        // clear any marked for complete removal (Note: don't check _isAboutToRemove as that is cleared above - just do it)\r\n        this._itemRemoving(node.el, false);\r\n\r\n        dd.on(el, 'drag', onDrag);\r\n        // make sure this is called at least once when going fast #1578\r\n        onDrag(event as DragEvent, el, helper);\r\n        return false; // prevent parent from receiving msg (which may be a grid as well)\r\n      })\r\n    /**\r\n     * Leaving our grid area...\r\n     */\r\n      .on(this.el, 'dropout', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n      // console.log(`out ${this.el.gridstack.opts.id} ${count++}`); // TEST\r\n        let node = el.gridstackNode;\r\n        if (!node) return false;\r\n        // fix #1578 when dragging fast, we might get leave after other grid gets enter (which calls us to clean)\r\n        // so skip this one if we're not the active grid really..\r\n        if (!node.grid || node.grid === this) {\r\n          this._leave(el, helper);\r\n          // if we were created as temporary nested grid, go back to before state\r\n          if (this._isTemp) {\r\n            this.removeAsSubGrid(node);\r\n          }\r\n        }\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      })\r\n    /**\r\n     * end - releasing the mouse\r\n     */\r\n      .on(this.el, 'drop', (event, el: GridItemHTMLElement, helper: GridItemHTMLElement) => {\r\n        let node = el.gridstackNode;\r\n        // ignore drop on ourself from ourself that didn't come from the outside - dragend will handle the simple move instead\r\n        if (node?.grid === this && !node._isExternal) return false;\r\n\r\n        const wasAdded = !!this.placeholder.parentElement; // skip items not actually added to us because of constrains, but do cleanup #1419\r\n        this.placeholder.remove();\r\n\r\n        // disable animation when replacing a placeholder (already positioned) with actual content\r\n        const noAnim = wasAdded && this.opts.animate;\r\n        if (noAnim) this.setAnimation(false);\r\n\r\n        // notify previous grid of removal\r\n        // console.log('drop delete _gridstackNodeOrig') // TEST\r\n        let origNode = el._gridstackNodeOrig;\r\n        delete el._gridstackNodeOrig;\r\n        if (wasAdded && origNode?.grid && origNode.grid !== this) {\r\n          let oGrid = origNode.grid;\r\n          oGrid.engine.removeNodeFromLayoutCache(origNode);\r\n          oGrid.engine.removedNodes.push(origNode);\r\n          oGrid._triggerRemoveEvent()._triggerChangeEvent();\r\n          // if it's an empty sub-grid that got auto-created, nuke it\r\n          if (oGrid.parentGridItem && !oGrid.engine.nodes.length && oGrid.opts.subGridDynamic) {\r\n            oGrid.removeAsSubGrid();\r\n          }\r\n        }\r\n\r\n        if (!node) return false;\r\n\r\n        // use existing placeholder node as it's already in our list with drop location\r\n        if (wasAdded) {\r\n          this.engine.cleanupNode(node); // removes all internal _xyz values\r\n          node.grid = this;\r\n        }\r\n        delete node.grid._isTemp;\r\n        dd.off(el, 'drag');\r\n        // if we made a copy ('helper' which is temp) of the original node then insert a copy, else we move the original node (#1102)\r\n        // as the helper will be nuked by jquery-ui otherwise. TODO: update old code path\r\n        if (helper !== el) {\r\n          helper.remove();\r\n          el.gridstackNode = origNode; // original item (left behind) is re-stored to pre dragging as the node now has drop info\r\n          if (wasAdded) {\r\n            el = el.cloneNode(true) as GridItemHTMLElement;\r\n          }\r\n        } else {\r\n          el.remove(); // reduce flicker as we change depth here, and size further down\r\n          this._removeDD(el);\r\n        }\r\n        if (!wasAdded) return false;\r\n        el.gridstackNode = node;\r\n        node.el = el;\r\n        let subGrid = node.subGrid?.el?.gridstack; // set when actual sub-grid present\r\n        // @ts-ignore\r\n        Utils.copyPos(node, this._readAttr(this.placeholder)); // placeholder values as moving VERY fast can throw things off #1578\r\n        Utils.removePositioningStyles(el);// @ts-ignore\r\n        this.el.appendChild(el);// @ts-ignore // TODO: now would be ideal time to _removeHelperStyle() overriding floating styles (native only)\r\n        this._prepareElement(el, true, node);\r\n        if (subGrid) {\r\n          subGrid.parentGridItem = node;\r\n          if (!subGrid.opts.styleInHead) subGrid._updateStyles(true); // re-create sub-grid styles now that we've moved\r\n        }\r\n        this._updateContainerHeight();\r\n        this.engine.addedNodes.push(node);// @ts-ignore\r\n        this._triggerAddEvent();// @ts-ignore\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n        if (this._gsEventHandler['dropped']) {\r\n          this._gsEventHandler['dropped']({...event, type: 'dropped'}, origNode && origNode.grid ? origNode : undefined, node);\r\n        }\r\n\r\n        // delay adding animation back\r\n        if (noAnim) setTimeout(() => this.setAnimation(this.opts.animate));\r\n\r\n        return false; // prevent parent from receiving msg (which may be grid as well)\r\n      });\r\n    return this;\r\n  }\r\n\r\n  /** @internal mark item for removal */\r\n  private _itemRemoving(el: GridItemHTMLElement, remove: boolean) {\r\n    let node = el ? el.gridstackNode : undefined;\r\n    if (!node || !node.grid || el.classList.contains(this.opts.removableOptions.decline)) return;\r\n    remove ? node._isAboutToRemove = true : delete node._isAboutToRemove;\r\n    remove ? el.classList.add('grid-stack-item-removing') : el.classList.remove('grid-stack-item-removing');\r\n  }\r\n\r\n  /** @internal called to setup a trash drop zone if the user specifies it */\r\n  protected _setupRemoveDrop(): GridStack {\r\n    if (!this.opts.staticGrid && typeof this.opts.removable === 'string') {\r\n      let trashEl = document.querySelector(this.opts.removable) as HTMLElement;\r\n      if (!trashEl) return this;\r\n      // only register ONE drop-over/dropout callback for the 'trash', and it will\r\n      // update the passed in item and parent grid because the 'trash' is a shared resource anyway,\r\n      // and Native DD only has 1 event CB (having a list and technically a per grid removableOptions complicates things greatly)\r\n      if (!dd.isDroppable(trashEl)) {\r\n        dd.droppable(trashEl, this.opts.removableOptions)\r\n          .on(trashEl, 'dropover', (event, el) => this._itemRemoving(el, true))\r\n          .on(trashEl, 'dropout',  (event, el) => this._itemRemoving(el, false));\r\n      }\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** @internal prepares the element for drag&drop */\r\n  protected _prepareDragDropByNode(node: GridStackNode): GridStack {\r\n    let el = node.el;\r\n    const noMove = node.noMove || this.opts.disableDrag;\r\n    const noResize = node.noResize || this.opts.disableResize;\r\n\r\n    // check for disabled grid first\r\n    if (this.opts.staticGrid || (noMove && noResize)) {\r\n      if (node._initDD) {\r\n        this._removeDD(el); // nukes everything instead of just disable, will add some styles back next\r\n        delete node._initDD;\r\n      }\r\n      el.classList.add('ui-draggable-disabled', 'ui-resizable-disabled'); // add styles one might depend on #1435\r\n      return this;\r\n    }\r\n\r\n    if (!node._initDD) {\r\n      // variables used/cashed between the 3 start/move/end methods, in addition to node passed above\r\n      let cellWidth: number;\r\n      let cellHeight: number;\r\n\r\n      /** called when item starts moving/resizing */\r\n      let onStartMoving = (event: Event, ui: DDUIData) => {\r\n        // trigger any 'dragstart' / 'resizestart' manually\r\n        if (this._gsEventHandler[event.type]) {\r\n          this._gsEventHandler[event.type](event, event.target);\r\n        }\r\n        cellWidth = this.cellWidth();\r\n        cellHeight = this.getCellHeight(true); // force pixels for calculations\r\n\r\n        this._onStartMoving(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when item is being dragged/resized */\r\n      let dragOrResize = (event: MouseEvent, ui: DDUIData) => {\r\n        this._dragOrResize(el, event, ui, node, cellWidth, cellHeight);\r\n      }\r\n\r\n      /** called when the item stops moving/resizing */\r\n      let onEndMoving = (event: Event) => {\r\n        this.placeholder.remove();\r\n        delete node._moving;\r\n        delete node._event;\r\n        delete node._lastTried;\r\n        const widthChanged = node.w !== node._orig.w;\r\n\r\n        // if the item has moved to another grid, we're done here\r\n        let target: GridItemHTMLElement = event.target as GridItemHTMLElement;\r\n        if (!target.gridstackNode || target.gridstackNode.grid !== this) return;\r\n\r\n        node.el = target;\r\n\r\n        if (node._isAboutToRemove) {\r\n          let grid = el.gridstackNode.grid;\r\n          if (grid._gsEventHandler[event.type]) {\r\n            grid._gsEventHandler[event.type](event, target);\r\n          }\r\n          grid.engine.nodes.push(node); // temp add it back so we can proper remove it next\r\n          grid.removeWidget(el, true, true);\r\n        } else {\r\n          Utils.removePositioningStyles(target);\r\n          if (node._temporaryRemoved) {\r\n            // got removed - restore item back to before dragging position\r\n            Utils.copyPos(node, node._orig);// @ts-ignore\r\n            this._writePosAttr(target, node);\r\n            this.engine.addNode(node);\r\n          } else {\r\n            // move to new placeholder location\r\n            this._writePosAttr(target, node);\r\n          }\r\n          if (this._gsEventHandler[event.type]) {\r\n            this._gsEventHandler[event.type](event, target);\r\n          }\r\n        }\r\n        // @ts-ignore\r\n        this._extraDragRow = 0;// @ts-ignore\r\n        this._updateContainerHeight();// @ts-ignore\r\n        this._triggerChangeEvent();\r\n\r\n        this.engine.endUpdate();\r\n\r\n        if (event.type === 'resizestop') {\r\n          if (Number.isInteger(node.sizeToContent)) node.sizeToContent = node.h; // new soft limit\r\n          this.resizeToContentCheck(widthChanged, node); // wait for width animation if changed\r\n        }\r\n      }\r\n\r\n      dd.draggable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        drag: dragOrResize\r\n      }).resizable(el, {\r\n        start: onStartMoving,\r\n        stop: onEndMoving,\r\n        resize: dragOrResize\r\n      });\r\n      node._initDD = true; // we've set DD support now\r\n    }\r\n\r\n    // finally fine tune move vs resize by disabling any part...\r\n    dd.draggable(el, noMove ? 'disable' : 'enable')\r\n      .resizable(el, noResize ? 'disable' : 'enable');\r\n\r\n    return this;\r\n  }\r\n\r\n  /** @internal handles actual drag/resize start */\r\n  protected _onStartMoving(el: GridItemHTMLElement, event: Event, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    this.engine.cleanNodes()\r\n      .beginUpdate(node);\r\n    // @ts-ignore\r\n    this._writePosAttr(this.placeholder, node)\r\n    this.el.appendChild(this.placeholder);\r\n    // console.log('_onStartMoving placeholder') // TEST\r\n\r\n    // if the element is inside a grid, it has already been scaled\r\n    // we can use that as a scale reference\r\n    if (node.grid?.el) {\r\n      this.dragTransform = Utils.getValuesFromTransformedElement(el);\r\n    }\r\n    // if the element is being dragged from outside (not from any grid)\r\n    // we use the grid as the transformation reference, since the helper is not subject to transformation\r\n    else if (this.placeholder && this.placeholder.closest('.grid-stack')) {\r\n      const gridEl = this.placeholder.closest('.grid-stack') as HTMLElement;\r\n      this.dragTransform = Utils.getValuesFromTransformedElement(gridEl);\r\n    }\r\n    // Fallback\r\n    else {\r\n      this.dragTransform = {\r\n        xScale: 1,\r\n        xOffset: 0,\r\n        yScale: 1,\r\n        yOffset: 0,\r\n      }\r\n    }\r\n\r\n    node.el = this.placeholder;\r\n    node._lastUiPosition = ui.position;\r\n    node._prevYPix = ui.position.top;\r\n    node._moving = (event.type === 'dragstart'); // 'dropover' are not initially moving so they can go exactly where they enter (will push stuff out of the way)\r\n    delete node._lastTried;\r\n\r\n    if (event.type === 'dropover' && node._temporaryRemoved) {\r\n      // console.log('engine.addNode x=' + node.x); // TEST\r\n      this.engine.addNode(node); // will add, fix collisions, update attr and clear _temporaryRemoved\r\n      node._moving = true; // AFTER, mark as moving object (wanted fix location before)\r\n    }\r\n\r\n    // set the min/max resize info\r\n    this.engine.cacheRects(cellWidth, cellHeight, this.opts.marginTop as number, this.opts.marginRight as number, this.opts.marginBottom as number, this.opts.marginLeft as number);\r\n    if (event.type === 'resizestart') {\r\n      dd.resizable(el, 'option', 'minWidth', cellWidth * (node.minW || 1))\r\n        .resizable(el, 'option', 'minHeight', cellHeight * (node.minH || 1));\r\n      if (node.maxW) { dd.resizable(el, 'option', 'maxWidth', cellWidth * node.maxW); }\r\n      if (node.maxH) { dd.resizable(el, 'option', 'maxHeight', cellHeight * node.maxH); }\r\n    }\r\n  }\r\n\r\n  /** @internal handles actual drag/resize */\r\n  protected _dragOrResize(el: GridItemHTMLElement, event: MouseEvent, ui: DDUIData, node: GridStackNode, cellWidth: number, cellHeight: number): void {\r\n    let p = {...node._orig}; // could be undefined (_isExternal) which is ok (drag only set x,y and w,h will default to node value)\r\n    let resizing: boolean;\r\n    let mLeft = this.opts.marginLeft as number,\r\n      mRight = this.opts.marginRight as number,\r\n      mTop = this.opts.marginTop as number,\r\n      mBottom = this.opts.marginBottom as number;\r\n\r\n    // if margins (which are used to pass mid point by) are large relative to cell height/width, reduce them down #1855\r\n    let mHeight = Math.round(cellHeight * 0.1),\r\n      mWidth = Math.round(cellWidth * 0.1);\r\n    mLeft = Math.min(mLeft, mWidth);\r\n    mRight = Math.min(mRight, mWidth);\r\n    mTop = Math.min(mTop, mHeight);\r\n    mBottom = Math.min(mBottom, mHeight);\r\n\r\n    if (event.type === 'drag') {\r\n      if (node._temporaryRemoved) return; // handled by dropover\r\n      let distance = ui.position.top - node._prevYPix;\r\n      node._prevYPix = ui.position.top;\r\n      if (this.opts.draggable.scroll !== false) {\r\n        Utils.updateScrollPosition(el, ui.position, distance);\r\n      }\r\n\r\n      // get new position taking into account the margin in the direction we are moving! (need to pass mid point by margin)\r\n      let left = ui.position.left + (ui.position.left > node._lastUiPosition.left  ? -mRight : mLeft);\r\n      let top = ui.position.top + (ui.position.top > node._lastUiPosition.top  ? -mBottom : mTop);\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      // @ts-ignore// if we're at the bottom hitting something else, grow the grid so cursor doesn't leave when trying to place below others\r\n      let prev = this._extraDragRow;\r\n      if (this.engine.collide(node, p)) {\r\n        let row = this.getRow();\r\n        let extra = Math.max(0, (p.y + node.h) - row);\r\n        if (this.opts.maxRow && row + extra > this.opts.maxRow) {\r\n          extra = Math.max(0, this.opts.maxRow - row);\r\n        }// @ts-ignore\r\n        this._extraDragRow = extra;// @ts-ignore\r\n      } else this._extraDragRow = 0;// @ts-ignore\r\n      if (this._extraDragRow !== prev) this._updateContainerHeight();\r\n\r\n      if (node.x === p.x && node.y === p.y) return; // skip same\r\n      // DON'T skip one we tried as we might have failed because of coverage <50% before\r\n      // if (node._lastTried && node._lastTried.x === x && node._lastTried.y === y) return;\r\n    } else if (event.type === 'resize')  {\r\n      if (p.x < 0) return;\r\n      // Scrolling page if needed\r\n      Utils.updateScrollResize(event, el, cellHeight);\r\n\r\n      // get new size\r\n      p.w = Math.round((ui.size.width - mLeft) / cellWidth);\r\n      p.h = Math.round((ui.size.height - mTop) / cellHeight);\r\n      if (node.w === p.w && node.h === p.h) return;\r\n      if (node._lastTried && node._lastTried.w === p.w && node._lastTried.h === p.h) return; // skip one we tried (but failed)\r\n\r\n      // if we size on left/top side this might move us, so get possible new position as well\r\n      let left = ui.position.left + mLeft;\r\n      let top = ui.position.top + mTop;\r\n      p.x = Math.round(left / cellWidth);\r\n      p.y = Math.round(top / cellHeight);\r\n\r\n      resizing = true;\r\n    }\r\n\r\n    node._event = event;\r\n    node._lastTried = p; // set as last tried (will nuke if we go there)\r\n    let rect: GridStackPosition = { // screen pix of the dragged box\r\n      x: ui.position.left + mLeft,\r\n      y: ui.position.top + mTop,\r\n      w: (ui.size ? ui.size.width : node.w * cellWidth) - mLeft - mRight,\r\n      h: (ui.size ? ui.size.height : node.h * cellHeight) - mTop - mBottom\r\n    };\r\n    if (this.engine.moveNodeCheck(node, {...p, cellWidth, cellHeight, rect, resizing})) {\r\n      node._lastUiPosition = ui.position;\r\n      this.engine.cacheRects(cellWidth, cellHeight, mTop, mRight, mBottom, mLeft);\r\n      delete node._skipDown;\r\n      if (resizing && node.subGrid) node.subGrid.onResize();\r\n      this._extraDragRow = 0;// @ts-ignore\r\n      this._updateContainerHeight();\r\n\r\n      let target = event.target as GridItemHTMLElement;// @ts-ignore\r\n      this._writePosAttr(target, node);\r\n      if (this._gsEventHandler[event.type]) {\r\n        this._gsEventHandler[event.type](event, target);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @internal called when item leaving our area by either cursor dropout event\r\n   * or shape is outside our boundaries. remove it from us, and mark temporary if this was\r\n   * our item to start with else restore prev node values from prev grid it came from.\r\n   */\r\n  protected _leave(el: GridItemHTMLElement, helper?: GridItemHTMLElement): void {\r\n    let node = el.gridstackNode;\r\n    if (!node) return;\r\n\r\n    helper = helper || el;\r\n    // restore the scale of the helper on leave\r\n    helper.style.transform = 'scale(1)';\r\n    dd.off(el, 'drag'); // no need to track while being outside\r\n\r\n    // this gets called when cursor leaves and shape is outside, so only do this once\r\n    if (node._temporaryRemoved) return;\r\n    node._temporaryRemoved = true;\r\n\r\n    this.engine.removeNode(node); // remove placeholder as well, otherwise it's a sign node is not in our list, which is a bigger issue\r\n    node.el = node._isExternal && helper ? helper : el; // point back to real item being dragged\r\n\r\n    if (this.opts.removable === true) { // boolean vs a class string\r\n      // item leaving us and we are supposed to remove on leave (no need to drag onto trash) mark it so\r\n      this._itemRemoving(el, true);\r\n    }\r\n\r\n    // finally if item originally came from another grid, but left us, restore things back to prev info\r\n    if (el._gridstackNodeOrig) {\r\n      // console.log('leave delete _gridstackNodeOrig') // TEST\r\n      el.gridstackNode = el._gridstackNodeOrig;\r\n      delete el._gridstackNodeOrig;\r\n    } else if (node._isExternal) {\r\n      // item came from outside (like a toolbar) so nuke any node info\r\n      delete node.el;\r\n      delete el.gridstackNode;\r\n      // and restore all nodes back to original\r\n      this.engine.restoreInitial();\r\n    }\r\n  }\r\n\r\n  // legacy method removed\r\n  public commit(): GridStack { obsolete(this, this.batchUpdate(false), 'commit', 'batchUpdate', '5.2'); return this; }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}